{"name":"DNSInfobloxPTRRecord","scriptType":"Python","scriptContent":"'''\n------------------------------------------------------\nTask Description :\n------------------------------------------------------\nThis task is used to create, modify and delete PTR record in Infloblox DNS device. It supports assigning Hostname (name + zone) to,\n\n��         IPAddress ( or )\n��         Next available address from the subnet\n\n. No rollback supported for Deferred task execution with subnet ( free ip auto detection )\n------------------------------------------------------\nVendor, Version Support :\n------------------------------------------------------\nVendor : Infoblox\nVersion : Version: 7.3.4-322642\n------------------------------------------------------\nTask Version : v1.0\nTask Type : Leaf Task\nExecution Type : Immediate and Deferred\nChecksum : f19b879a7905dbb790d845240d1f36b9\n'''\nimport ast\n\nimport re\nimport requests\nimport json\nimport time\nimport traceback\nimport sys\nimport logger_util\n\n\nsys.path.insert(0,AVX::HELPER)\nsys.path.insert(0,AVX::DEPENDENCIES)\nimport infoblox_helper as infoblox\nimport Decrypt_Python3 as Decrypt\nfrom requests.auth import HTTPBasicAuth\nfrom base64 import b64encode\nimport oob_task_utility\nimport oob_constants\nfrom DNSInfoblox import DNSInfoblox\n\nlogger = logger_util.get_logger('DNS Infoblox PTR Record')\n\nnull = None\n\n# DNSInfobloxPTRRecord - This class handles the PTR record Creation along with its rollback\nclass DNSInfobloxPTRRecord(DNSInfoblox):\n\n    list_of_fields_for_clean = [    \n                                    DNSInfoblox.PTRD_NAME,\n                                    DNSInfoblox.PROPOSED_PTRD_NAME,\n                                    DNSInfoblox.ZONE,\n                                    DNSInfoblox.PROPOSED_ZONE,\n                                    DNSInfoblox.VIEW,\n                                    DNSInfoblox.IPV4ADDR,\n                                    DNSInfoblox.IPV6ADDR,\n                                    DNSInfoblox.PROPOSED_IPV4ADDR,\n                                    DNSInfoblox.PROPOSED_IPV6ADDR,\n                                    DNSInfoblox.COMMENT,\n                                    DNSInfoblox.CREATOR,\n                                    DNSInfoblox.SUBNET,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.DDNS_PRINCIPAL\n                                ]\n    list_of_fields_for_create_validation = [\n                                    DNSInfoblox.PTRD_NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    \n                                    \n                                ]\n    list_of_fields_for_delete_modify_validation = [\n                                    DNSInfoblox.PTRD_NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME\n                                ]\n\n    @classmethod\n    def validate_fields_create_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n\n        ipv4addr_subnet_validation_result = (   self.mandatory_string_validation(input_dict[DNSInfoblox.IPV6ADDR],\n                                                DNSInfoblox.IPV6ADDR,False) or self.mandatory_string_validation(input_dict[DNSInfoblox.IPV4ADDR],\n                                                DNSInfoblox.IPV4ADDR,False) or self.mandatory_string_validation(input_dict[DNSInfoblox.SUBNET],\n                                                DNSInfoblox.SUBNET,False) )\n        if not ipv4addr_subnet_validation_result:\n            logger.info(\"IP address and Subnet validation failed\")\n        status = status and ipv4addr_subnet_validation_result\n        failure_field = \"IP address and Subnet validation \" if not status and failure_field == None else failure_field\n\n        return status,failure_field\n    \n    @classmethod\n    def validate_fields_delete_and_modify_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n        status1 = True\n        status = status and self.mandatory_string_validation(input_dict[DNSInfoblox.IPV4ADDR],DNSInfoblox.IPV4ADDR,True) and oob_task_utility.ipv4addr_validation(input_dict[DNSInfoblox.IPV4ADDR],DNSInfoblox.IPV4ADDR)\n        status1 = status1 and self.mandatory_string_validation(input_dict[DNSInfoblox.IPV6ADDR],DNSInfoblox.IPV6ADDR,True) and oob_task_utility.ipv6addr_validation(input_dict[DNSInfoblox.IPV6ADDR],DNSInfoblox.IPV6ADDR)\n        failure_field = DNSInfoblox.IPV4ADDR if not status and failure_field == None else (DNSInfoblox.IPV6ADDR if not status1 and failure_field == None else failure_field)\n        \n        return status,failure_field\n\n    def __init__(self, input_dict):\n        logger.info(\"Creating Object with input :\"+str(input_dict))\n        self.ptrdname                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PTRD_NAME)\n        self.proposed_ptrdname          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_PTRD_NAME)\n        self.zone                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ZONE)\n        self.proposed_zone          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_ZONE)\n        self.view                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.VIEW)\n        self.ipv4addr               = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IPV4ADDR)\n        self.ipv6addr               = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IPV6ADDR)\n        self.proposed_ipv4addr      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_IPV4ADDR)\n        self.proposed_ipv6addr      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_IPV6ADDR)\n        self.comment                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.COMMENT)\n        self.is_disable             = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IS_DISABLE)\n        self.creator                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CREATOR)\n        self.ddns_principal         = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PRINCIPAL)\n        self.ddns_protected         = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PROTECTED)\n        self.extattrs               = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.EXTATTRS)\n        self.forbid_reclamation     = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.FORBID_RECLAMATION)\n        self.ttl                    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.TTL)\n        self.use_ttl                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_TTL)\n\n        self.subnet                 = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.SUBNET)\n\n        self.device_name            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.DEVICE_NAME) \n        self.device_ip              = infoblox.get_device_ip(self.device_name)\n        \n        self.api_version            = infoblox.get_device_version(self.device_name)\n       \n        username,password           = Decrypt.getpassword(self.device_name)\n        self.device_user_name       = username\n        self.device_password        = password\n\n        self.is_rollback            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_ROLLBACK) \n        self.rollback_input         = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.ROLLBACK_INPUT)\n        self.is_deferred_execution  = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_DEFERRED_EXECUTION)\n        self.record_type            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.RECORD_TYPE)\n\n        #To choose from the version of ip address to be used\n        self.ip_version_dict = self.validate_input_ipaddr(self.ipv4addr, self.ipv6addr)\n        if bool(self.ip_version_dict) != False:\n            self.ipaddr = self.ip_version_dict[\"ipaddr\"]\n            self.dns_infoblox_ip = self.ip_version_dict[\"dns_infoblox_ip\"]\n            self.proposed_ipaddr = self.ip_version_dict[\"proposed_ipaddr\"]\n            \n\n    #Method to validate ip address based on the input\n    def validate_input_ipaddr(self,ipv4addr, ipv6addr):\n        validation_result = {}\n        if ipv4addr != None and ipv4addr != \"\":\n            validation_result[\"dns_infoblox_ip\"]=DNSInfoblox.IPV4ADDR\n            validation_result[\"ipaddr\"] = ipv4addr\n            validation_result[\"proposed_ipaddr\"] = self.proposed_ipv4addr\n            validation_result[\"dns_infoblox_ipaddrs\"]=DNSInfoblox.IPV4ADDRS\n            validation_result[\"dns_infoblox_ipaddr\"] = DNSInfoblox.IPV4ADDR\n        elif ipv6addr != None and ipv6addr != \"\":\n            validation_result[\"dns_infoblox_ip\"]=DNSInfoblox.IPV6ADDR\n            validation_result[\"ipaddr\"] = ipv6addr\n            validation_result[\"proposed_ipaddr\"] = self.proposed_ipv6addr\n            validation_result[\"dns_infoblox_ipaddrs\"]=DNSInfoblox.IPV6ADDRS\n            validation_result[\"dns_infoblox_ipaddr\"] = DNSInfoblox.IPV6ADDR\n        return validation_result\n\n    #Method to Prevalidate for PTR Record Creation\n    def prevalidate_create(self):\n        return super().validate_record({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1},False)\n\n    #Method to Postvalidate for PTR Record Creation\n    def postvalidate_create(self):\n        return super().validate_record({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1},True)\n\n    #todo\n    def postvalidate_modify(self):\n        validation_name = ( self.proposed_ptrdname if self.proposed_ptrdname!=None and self.proposed_ptrdname!=\"\" else self.ptrdname )+'.'+( self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone)\n        validation_ipaddr = self.proposed_ipaddr if self.proposed_ipaddr!=None and self.proposed_ipaddr!=\"\" else self.ipaddr\n        return super().validate_record({DNSInfoblox.PTRD_NAME:validation_name,self.dns_infoblox_ip:validation_ipaddr,\"_return_as_object\":1},True)\n\n    #Method to execute immediate PTR record creation\n    def create_immediate(self):\n        logger.info(\"Creation Immediate Started\")\n        request_dict = self.get_request_dict_for_record_creation()\n        output = {}\n        try:\n            response = requests.post(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n            response_json = response.json()\n            logger.info(\"PTR Record Creation Response :\"+str(response_json))\n\n            if self.subnet != None and self.subnet != \"\":\n                logger.info(\"New IP received :\")\n\n                if oob_constants.RESULT in response_json and self.dns_infoblox_ip in response_json[oob_constants.RESULT]:\n                    self.ipaddr = response_json[oob_constants.RESULT][self.dns_infoblox_ip]\n                logger.info(\"self.ipaddr : \"+str(self.ipaddr))\n\n            #Check Error in a_record_create_response\n            isAlreadyExists = \"Error\" in response_json and \"already exists\" in str(response_json[\"Error\"])\n            \n            if isAlreadyExists:\n                logger.info(\"Record Already Exists\")\n                raise Exception(\"Record Already Exists\")\n            elif \"Error\" in response_json:\n                raise Exception(str(response_json[\"Error\"]))\n            \n            input_dict = self.__dict__\n            input_dict[self.dns_infoblox_ip] = self.ipaddr\n\n            output[oob_constants.STATUS] = oob_constants.SUCCESS\n            self.add_record_type_specific_fields(output)            \n            output[oob_constants.ROLLBACK] = input_dict\n\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            logger.info(\"Exception received \"+str(exception))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            # Rollback for failure scenario\n            self.delete_immediate()\n\n        return output\n\n    #Method to execute delete PTR record immediate\n    def delete_immediate(self):\n        output =  super().delete_immediate({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1})\n        if oob_constants.STATUS in output and output[oob_constants.STATUS]==oob_constants.SUCCESS:\n            self.add_record_type_specific_fields(output)            \n        return output\n    \n    #Method to execute delete PTR record deferred\n    def delete_deferred(self):\n        output = super().delete_deferred({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1})        \n        self.add_record_type_specific_fields(output)        \n        return output\n\n    #Method to execute prepare rest for delete partial rollback\n    def delete_partial_rollback(self):\n        logger.info(\"Inside delete_partial_rollback :\")\n        return super().delete_partial_rollback_rest({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_type\":\"json-pretty\"})\n\n\n    def modify_immediate(self):\n        logger.info(\"Implement immediate started\")\n        output = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.PTRD_NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+self.dns_infoblox_ip+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                response = requests.put(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n                response_json = response.json()\n                logger.info(\"PTR record modification response :\"+str(response_json))\n                if \"Error\" in response_json:\n                    raise Exception(str(response_json[\"Error\"]))\n                #backup the changed properties\n                if not self.is_rollback:\n                    rollback_data = {}\n                    record_response_dict = record_response[oob_constants.RESULT][0];\n                    modified_dict = request_dict[oob_constants.PAYLOAD];\n                    rollback_data = {x:record_response_dict[x] for x in record_response_dict if x in modified_dict} \n                    rollback_input_dict = self.build_modify_rollback_input(rollback_data, request_dict[oob_constants.PAYLOAD])\n                    output[oob_constants.ROLLBACK] = rollback_input_dict\n\n                name = self.ptrdname if DNSInfoblox.PTRD_NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_ptrdname\n                zone = self.zone if DNSInfoblox.PTRD_NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_zone\n                fqdn = self.ptrdname+\".\"+self.zone if DNSInfoblox.PTRD_NAME not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.PTRD_NAME]\n                ipv4addr = self.ipaddr if self.dns_infoblox_ip not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][self.dns_infoblox_ip]\n\n                output[oob_constants.STATUS] = oob_constants.SUCCESS\n                output[DNSInfoblox.PTRD_NAME] = name\n                output[DNSInfoblox.ZONE] = zone\n                output[DNSInfoblox.FQDN] = fqdn\n                output[self.dns_infoblox_ip] = ipv4addr\n                self.add_record_type_specific_fields(output)\n                return output\n            else:\n                raise Exception(\"Error in fetching the PTR Record. PTR Record was not found in device\")\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during modify operation\")    \n            return output\n\n    #Rollback Not supported\n    def modify_deferred(self):\n        logger.info(\"Implement deferred - generating commands started\")\n        rest = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.PTRD_NAME:self.ptrdname+'.'+self.zone,self.dns_infoblox_ip:self.ipaddr,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.PTRD_NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+self.dns_infoblox_ip+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                rest[oob_constants.DEVICE_NAME] = self.device_name\n                rest[oob_constants.HEADERS] = self.get_authorization_dict()\n                rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n                rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n                rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD]\n            else:\n                logger.info(\"Error in fetching the PTR Record\")\n                raise Exception(\"Error in fetching the PTR Record. PTR Record was not found in device\")\n            \n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n        self.add_record_type_specific_fields(output)\n        return output\n\n    # Method to modify PTR record\n    def get_request_dict_for_record_modification(self,record_reference):\n        logger.info(\"Triggered modify PTR record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/'+record_reference+'?_return_fields=name,ipv4addr&_return_as_object=1'\n        payload = {}\n        logger.info(\"type of ttl :\"+str(type(self.ttl)))\n        if (self.proposed_ptrdname!=None and self.proposed_ptrdname!=self.ptrdname ) or (self.proposed_zone!=None and self.proposed_zone!=self.zone):\n            payload_name =(self.proposed_ptrdname if self.proposed_ptrdname else self.ptrdname)+'.'+(self.proposed_zone if self.proposed_zone else self.zone)\n            self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.PTRD_NAME,payload_name)        \n\n        self.addFieldIfNotNoneForModifyRollback(payload,self.dns_infoblox_ip,self.proposed_ipaddr)\n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"PTR Record Modify Payload : \"+str(json.dumps(payload)))\n        logger.info(\"PTR Record Modify Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'PUT'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    # Method to create 'A' record\n    def get_request_dict_for_record_creation(self):\n        logger.info(\"Triggered Create PTR record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/record:'+DNSInfoblox.PTR_RECORD_TYPE+'?_return_fields=name,ipv4addr&_return_as_object=1'\n        payload = {}\n        \n        #Mandatory\n        payload[DNSInfoblox.PTRD_NAME] = self.ptrdname+\".\"+self.zone\n\n        logger.info(\"self.ipaddr\"+str(self.ipaddr))\n        \n        # Handle ipv4addr and subnet for creating the records\n        if self.ipaddr != None and self.ipaddr != \"\":    \n            logger.info(\"ipv4addr received : \"+self.ipaddr)\n            payload[self.dns_infoblox_ip] = self.ipaddr\n\n        elif self.subnet != None and self.subnet != \"\":\n            logger.info(\"subnet received :\"+self.subnet)\n            payload[self.dns_infoblox_ip] = 'func:nextavailableip:'+self.subnet\n\n        else:\n            logger.info({\"either ipv4addr or subnet received\"})\n            return\n\n        #Optional\n        self.addFieldIfNotNone(payload,DNSInfoblox.VIEW,self.view)\n        self.addFieldIfNotNone(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNone(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNone(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNone(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNone(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"PTR Record Creation Payload : \"+str(json.dumps(payload)))\n        logger.info(\"PTR Record Creation Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'POST'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    #function to assign the values for rollback\n    def build_delete_rollback_input(self,record_response):\n        rollback_input_dict = {}\n\n        list_of_fields_for_rollback_input_dict_generation = [\n                                                                DNSInfoblox.PTRD_NAME,\n                                                                DNSInfoblox.ZONE,\n                                                                DNSInfoblox.VIEW,\n                                                                self.dns_infoblox_ip,\n                                                                DNSInfoblox.COMMENT,\n                                                                DNSInfoblox.CREATOR,\n                                                                DNSInfoblox.IS_DISABLE,\n                                                                DNSInfoblox.DDNS_PRINCIPAL,\n                                                                DNSInfoblox.DDNS_PROTECTED,\n                                                                DNSInfoblox.EXTATTRS,\n                                                                DNSInfoblox.FORBID_RECLAMATION,\n                                                                DNSInfoblox.TTL,\n                                                                DNSInfoblox.USE_TTL\n                                                            ]\n        \n        for field_name in list_of_fields_for_rollback_input_dict_generation:\n            rollback_input_dict[field_name]                     = oob_task_utility.getKeyValueIfAvailable(record_response,field_name)\n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = True \n\n        return rollback_input_dict\n\n    #function to assign the values for rollback\n    def build_modify_rollback_input(self,current_device_values,modify_payload):\n        rollback_input_dict = {}\n       \n        rollback_input_dict[DNSInfoblox.PROPOSED_PTRD_NAME]      = self.proposed_ptrdname if self.proposed_ptrdname!=None and self.proposed_ptrdname!=\"\" else self.ptrdname\n        rollback_input_dict[DNSInfoblox.PROPOSED_ZONE]      = self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone\n        rollback_input_dict[DNSInfoblox.PROPOSED_IPV4ADDR]  = self.returnFieldValueIfNotNone(self.dns_infoblox_ip,current_device_values, modify_payload) if self.dns_infoblox_ip not in  modify_payload else modify_payload[self.dns_infoblox_ip]\n        \n        list_of_field_names_for_rollback_input_dict = [\n                                                        DNSInfoblox.VIEW,\n                                                        DNSInfoblox.COMMENT,\n                                                        DNSInfoblox.CREATOR,\n                                                        DNSInfoblox.DISABLE,\n                                                        DNSInfoblox.DDNS_PRINCIPAL,\n                                                        DNSInfoblox.DDNS_PROTECTED,\n                                                        DNSInfoblox.EXTATTRS,\n                                                        DNSInfoblox.FORBID_RECLAMATION,\n                                                        DNSInfoblox.TTL,\n                                                        DNSInfoblox.USE_TTL\n                                                    ]\n\n        for property_field in list_of_field_names_for_rollback_input_dict:\n            #rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n            # Value from current_device_values only if both dict has key in it\n            property_field_value = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)\n            \n            if property_field in DNSInfoblox.default_value_dict and ( property_field_value==None or property_field_value==''):\n                property_field_value = DNSInfoblox.default_value_dict[property_field]\n\n            if property_field_value!=None and property_field_value!='':\n                rollback_input_dict[property_field] = property_field_value\n            #To handle int or bool field_type in case of empty or None from Device\n            elif property_field in DNSInfoblox.properties_data_type:\n                if (property_field_value is None or property_field_value == '') and (DNSInfoblox.properties_data_type[property_field] != 'int' or DNSInfoblox.properties_data_type[property_field] != 'bool'):\n                    rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[self.dns_infoblox_ip]               = self.ipaddr\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = self.is_rollback\n        rollback_input_dict[DNSInfoblox.RECORD_TYPE]            = self.record_type\n\n        return rollback_input_dict\n    \n    def add_basic_fields_from_object_to_dict(self,output):\n        output[DNSInfoblox.PTRD_NAME]                   = self.ptrdname\n        output[DNSInfoblox.ZONE]                   = self.zone\n        output[oob_constants.DEVICE_NAME]          = self.device_name    \n        output[oob_constants.IS_DEFERRED_EXECUTION]          = self.is_deferred_execution\n        output[oob_constants.ROLLBACK_INPUT]       = self.rollback_input\n\n    def add_record_type_specific_fields(self,output):\n        output[self.dns_infoblox_ip] = self.ipaddr\n        output[DNSInfoblox.PTRD_NAME] = self.ptrdname\n        output[DNSInfoblox.ZONE] = self.zone\n        output[DNSInfoblox.FQDN] = self.ptrdname+\".\"+self.zone\n\n    # Method for swapping the object identifier,to handle the change in the name of the identifier\n    def modify_swap(self):\n        if self.is_rollback:\n            if self.ptrdname != self.proposed_ptrdname and self.proposed_ptrdname != None:\n                self.ptrdname, self.proposed_ptrdname = self.proposed_ptrdname, self.ptrdname\n            if self.zone != self.proposed_zone and self.proposed_zone != None:\n                self.zone, self.proposed_zone = self.proposed_zone, self.zone\n            if self.ipaddr != self.proposed_ipaddr and self.proposed_ipaddr != None:\n                self.ipaddr, self.proposed_ipaddr = self.proposed_ipaddr, self.ipaddr","description":"DNSInfobloxPTRRecord","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":{"committed":true,"pendingForPushAction":true,"pushActionCompleted":false,"enabledForRemoteRepository":true,"connectedRepo":null},"_id":"DNSInfobloxPTRRecord","_keywords":["DNSInfobloxPTRRecord","Version 3.x"]}