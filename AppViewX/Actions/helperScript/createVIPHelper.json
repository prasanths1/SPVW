{"name":"createVIPHelper","scriptType":"Python","scriptContent":"\nimport sys\nimport json\n\nsys.path.append(AVX::HELPER)\nsys.path.append(AVX::DEPENDENCIES)\n\n#Import module pymongo\nimport pymongo\nfrom pymongo import MongoClient\n\nimport appviewx\nimport logger_util\nlogger = logger_util.get_logger('CREATE VIP HELPER')\n\n\nconnect_db = appviewx.db_connection()\ndef fetchDCList():\n    db = connect_db.appviewx\n    collection = db.device\n    dcList=[]\n    for value in collection.find():\n        try:\n            dcList.append(value['dataCenter'])\n        except:\n            pass\n    dcSet=set(dcList)\n    dcList=list(dcSet)\n    return dcList\n\n\ndef fetchDGList(dcName):\n    db = connect_db.appviewx\n    device_collection = db.device\n    dgList=[]\n    dgList_final = []\n    # for value in collection.find({\"dataCenter\":dcName}):\n    #     try:\n    #         dgListforValue=value['deviceGroups']\n    #     except KeyError:\n    #         continue\n    #     for index in range(len(dgListforValue)):\n    #         dgList.append(dgListforValue[index])\n    #     for val in dgList:\n    #         for val1 in collection1.find({\"_id\":val}):\n    #             dgList_final.append(val1[\"name\"])\n    # dgSet=set(dgList_final)\n    # dgList=list(dgSet)\n\n    # for value in device_collection.find({'dataCenter': dcName}):\n    #     for dg in value['deviceGroups']:\n    #         dgList.append(dg)\n\n    dgList = [dg for value in device_collection.find({'dataCenter': dcName}) for dg in value['deviceGroups']]\n    dgList=list(set(dgList))\n    return dgList\n\ndef fetch_lb_list(device_group, data_center, field_id=None):\n    \"\"\"Return list if lb names in the device group specified and for the data center\n    \"\"\"\n    db = connect_db.appviewx\n    dev_grp_id = db.deviceGroup.find_one({'name': device_group}, {'_id': 1})['_id']\n    lb_list = [device['name'] for device in db.device.find({'dataCenter': data_center, 'deviceGroups': {'$in': [dev_grp_id]}}, \n                {'name': 1}) if device and device['name'] not in ('', None, 'null')]\n    lb_list = sorted(lb_list, key = lambda s: s.lower())\n    if field_id:\n        return [{field_id: lb_name} for lb_name in lb_list]\n    else:\n        return lb_list\n\ndef fetch_asm_lb_list(device_group, data_center, field_id=None):\n    \"\"\"Return list if asm lb names in the device group specified and for the data center\n    \"\"\"\n    db = connect_db.appviewx\n    dev_grp_id = db.deviceGroup.find_one({'name': device_group}, {'_id': 1})['_id']\n    lb_list = [device['name'] for device in db.device.find({'dataCenter': data_center, 'deviceGroups': {'$in': [dev_grp_id]} }, {'name': 1}) if device and device['name'] not in ('', None, 'null')]\n    lb_list = sorted(lb_list, key = lambda s: s.lower())\n    if field_id:\n        return [{field_id: lb_name} for lb_name in lb_list]\n    else:\n        return lb_list\n\ndef check_asm_support(device_name):\n    \"\"\"Return True if device support asm else False\n    \"\"\"\n    db = connect_db.appviewx\n    if db.device.find_one({\"_keywords\" : {'$in': [\"ASM\",\"WAF\"]},'subsystem': 'LoadBalancer', 'name': device_name}):\n        return True\n    else:\n        return False\n        \ndef fetchLBList(dgName):\n    db = connect_db.appviewx\n    collection = db.device\n    dg_group = ''\n    lbList=[]\n    for value in collection.find({'deviceGroups':dgName}):\n        lbList.append(value['name'])\n    lbList.sort()\n    return lbList\n\ndef fetchDeviceID(devicename):\n    db = connect_db.appviewx\n    collection = db.device\n    for value in collection.find({\"name\": devicename}):\n        op = str(value['_id'])\n    return op\n\n\ndef fetchRuleList(deviceName):\n    db = connect_db.appviewx\n    collection = db.device\n    deviceid=fetchDeviceID(deviceName)\n    collection = db.me_adc\n    ruleList=[]\n    for value in collection.find({'deviceId':deviceid,\"code\":\"lr\"}):\n        ruleList.append(value['name'])\n    return ruleList\n\ndef fetchProfiles(deviceName,protocol):\n    db = connect_db.appviewx\n    collection = db.device\n    deviceid=fetchDeviceID(deviceName)\n    collection = db.me_adc\n    profList=[]\n    for value in collection.find({'deviceId':deviceid,'type':protocol,\"code\":\"lpr\"}):\n        profList.append(value['name'])\n    return profList\n\ndef fetchMonitors(deviceName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    monitors=[]\n    deviceid=fetchDeviceID(deviceName)\n    for value in collection.find({\"deviceId\": deviceid,\"code\":\"lm\"}):\n            monitors.append(value['name'])\n    return sorted(monitors, key=lambda s: s.lower())\n\ndef fetchMonitors_createvip(deviceName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    monitors=[]\n    deviceid=fetchDeviceID(deviceName)\n    for value in collection.find({\"deviceId\": deviceid,\"code\":\"lm\", \"type\": {\"$ne\": \"external\"}}):\n            monitors.append(value['name'])\n    return sorted(monitors, key=lambda s: s.lower())\n\n    \ndef fetchCertNames(deviceName):\n    db = connect_db.appviewx\n    collection = db.certificates\n    certnames=[]\n    deviceid=fetchDeviceID(deviceName)\n    for value in collection.find({'deviceId':{'$in':[deviceid]}}):\n        certnames.append(value['name'])\n    return certnames\n\ndef fetchCertKeyNames(deviceName):\n    db = connect_db.appviewx\n    collection = db.certificates\n    certkeynames=[]\n    deviceid=fetchDeviceID(deviceName)\n    for value in collection.find({'deviceId':{'$in':[deviceid]}}):\n        certkeynames.append(value['keyId'])\n    return certkeynames\n    \ndef fetchVipNames(deviceName):\n    deviceid=fetchDeviceID(deviceName)\n    db = connect_db.appviewx\n    collection = db.me_adc\n    VIPnames=[]\n    for value in collection.find({'deviceId':deviceid,\"code\":\"vs\"}):\n        VIPnames.append(value['name'])\n    return VIPnames\n\ndef fetchVipNameswithIPport(deviceName):\n    deviceid=fetchDeviceID(deviceName)\n    db = connect_db.appviewx\n    collection = db.me_adc\n    VIPnames=[]\n    for value in collection.find({'deviceId':deviceid,\"code\":\"vs\"}):\n        name = value['name']\n        ip = value[\"destinationIp\"]\n        port = value[\"destinationPort\"]\n        temp = name+\" || \"+ip+\":\"+port\n        VIPnames.append(temp)\n    return sorted(VIPnames, key=lambda s: s.lower())\n    \ndef fetchClientAndServerProf(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    serverProf=[]\n    clientProf=[]\n    serverProf1=[]\n    clientProf1=[]\n    destPort=[]\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        clientProf.append(value['clientprofile'])\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        serverProf.append(value['serverprofile'])\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        destPort.append(value['destinationPort'])\n    collection1=db.me_adc\n    try :\n        clientProf=clientProf[0].split(',')\n        serverProf=serverProf[0].split(',')\n    except IndexError:\n        pass\n    for i in range(len(clientProf)):\n        for value in collection1.find({'name':clientProf[i],\"code\":\"lpr\"}):\n            if value['type']=='client-ssl':\n                clientProf1.append(value['name'])\n    for i in range(len(serverProf)):\n        for value in collection1.find({'name':serverProf[i],\"code\":\"lpr\"}):\n            if value['type']=='server-ssl':\n                serverProf1.append(value['name'])\n    profiles=[]\n    profiles.append(serverProf1)\n    profiles.append(clientProf1)\n    profiles.append(destPort)\n    return profiles\n\ndef fetchClientAndServerProtProf(deviceName,vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    serverProf=[]\n    clientProf=[]\n    serverProf1=[]\n    clientProf1=[]\n    destPort=[]\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        clientProf.append(value['clientprofile'])\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        serverProf.append(value['serverprofile'])\n    deviceId=fetchDeviceID(deviceName)  \n    clientProf=clientProf[0].split(',')\n    serverProf=serverProf[0].split(',')\n    collection1=db.lpr\n    for i in range(len(clientProf)):\n        for value in collection1.find({'name':clientProf[i],'deviceId':deviceId}):\n            if value['type']!='client-ssl':\n                clientProf1.append(value['name'])\n    for i in range(len(serverProf)):\n        for value in collection1.find({'name':serverProf[i],'deviceId':deviceId}):\n            if value['type']!='server-ssl':\n                serverProf1.append(value['name'])\n    profiles=[]\n    profiles.append(serverProf1)\n    profiles.append(clientProf1)\n    return profiles\n\n    \ndef fetchProfBasedOnVip(vipName,typee):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    collection1=db.me_adc\n    Prof=[]\n    if(typee=='persist'):\n                \n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            Prof.append(value['persist'])\n    elif(typee=='fallback'):\n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            Prof.append(value['fallback'])\n    elif(typee=='oneconn'):\n        Prof1=[]\n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            temp=value['profiles'][0].split(',')\n            Prof1=Prof1+temp\n        for i in range(len(Prof1)):\n            for value in collection1.find({'name':Prof1[i],\"code\":\"lpr\"}):\n                if (value['type']=='one-connect'):\n                    Prof.append(value['name'])\n\n    elif(typee=='http'):\n        Prof1=[]\n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            temp=value['profiles'][0].split(',')\n            Prof1=Prof1+temp\n        for i in range(len(Prof1)):\n            for value in collection1.find({'name':Prof1[i],\"code\":\"lpr\"}):\n                if value['type']=='http':\n                    Prof.append(value['name'])\n    elif(typee=='ftp'):\n        Prof1=[]\n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            temp=value['profiles'][0].split(',')\n            Prof1=Prof1+temp\n        for i in range(len(Prof1)):\n            for value in collection1.find({'name':Prof1[i],\"code\":\"lpr\"}):\n                if value['type']=='ftp':\n                    Prof.append(value['name'])\n\n    elif(typee=='snat'):\n        Prof=[]\n        for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n            temp=value['snat'].split(',')\n            Prof=Prof+temp\n\n    prof_set=set(Prof)\n    Prof=list(prof_set)\n    return Prof\n    \n    \ndef fetchPoolsBasedonVip(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    #collection1=db.lp\n    Pools=[]\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        temp=value['pool'].split(',')\n        Pools=Pools+temp\n    return Pools\n\ndef fetchPoolsBasedonVipwithdeviceid(vipName,deviceName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    #collection1=db.lp\n    deviceid=fetchDeviceID(deviceName)\n    Pools=[]\n    for value in collection.find({'name':vipName,\"code\":\"vs\",\"deviceId\":deviceid}):\n        temp=value['pool'].split(',')\n        Pools=Pools+temp\n    return Pools\n\ndef fetchMonitorsBasedonPool(poolName):\n    db = connect_db.appviewx\n    collection=db.me_adc\n    Monitors=[]\n    for value in collection.find({'name':poolName,\"code\":\"lp\"}):\n        temp=value['monitorAll']\n        Monitors=Monitors+temp\n    return Monitors\n\ndef fetchRulesBasedonVip(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    Rules=[]\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        temp=value['rules']\n        Rules=Rules+temp\n    return Rules\n    \ndef fetchMirrorStatus(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    mirr=''\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        mirr=value['mirror']\n    return mirr\n\ndef fetchlbMethod(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    pool=fetchPoolsBasedonVip(vipName)\n    lbm=''\n    for value in collection.find({'name':pool[0],\"code\":\"lp\"}):\n        lbm=value['lbmode']\n    return lbm\n\ndef fetchPoolMembersOfVip(vipName):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    collection1 = db.me_adc\n    pool=fetchPoolsBasedonVip(vipName)\n    pool_mems=[]\n    pool_mems_list_of_dict=[]\n    for value in collection.find({'name':pool[0],\"code\":\"lp\"}):\n        pool_mems=value['lpm']\n    for i in range(len(pool_mems)):\n        for value in collection1.find({'_id':pool_mems[i],\"code\":\"lpm\"}):\n            member_dict={'pm_ip_addr':value['ip'],'pm_port':value['port'],'ratio':value['ratio'],'status_id':value['state'],'priority':value['priority']}\n            pool_mems_list_of_dict.append(member_dict)\n    return pool_mems_list_of_dict\n    \ndef fetchSourcePort(vipName):\n        \n    db = connect_db.appviewx\n    collection = db.me_adc\n    srcPort=''\n    for value in collection.find({'name':vipName,\"code\":\"vs\"}):\n        srcPort=value['sourcePort']\n    return srcPort\ndef split_vip(vip_name):\n    temp = vip_name.split(\"||\")[0].rstrip()\n    return temp\n\ndef fetchPriorityGroup(vipName):\n    poolName = fetchPoolsBasedonVip(vipName)\n    db = connect_db.appviewx\n    collection = db.me_adc\n    priorityGrpstatus = ''\n    for value in collection.find({'name':poolName[0],\"code\":\"lp\"}):\n        priorityGrpstatus = value['priority']\n    return priorityGrpstatus\n\ndef return_path():\n    import os\n    abs_path = os.path.dirname(os.path.abspath(__file__))\n    return abs_path\n\ndef create_listofcommands_for_pending_wo(final_list_of_commands,field_id_of_validate_across_workorder):\n    sys.path.insert(0,AVX::DEPENDENCIES)\n    sys.path.insert(0,AVX::HELPER)\n    import pymongo\n    from pymongo import MongoClient,ReadPreference\n    # import socket\n    # db_ip = socket.gethostbyname(socket.gethostname())\n    # connect_db = MongoClient(db_ip, 5000)\n    # connect_db.admin.authenticate('admin','admin')\n    username,password,dbname = \"admin\",\"admin\",\"admin\"\n\n\n    conf_file = appviewx.get_conf_file()\n    conf_content = appviewx.get_conf_content(conf_file)\n    if conf_content['APPVIEWX_DB_REPLICATION']=='TRUE':\n        mongo_ip=conf_content['APPVIEWX_DB_PRIMARY_HOST']+':'+conf_content['APPVIEWX_DB_PRIMARY_PORT']\n        mongo_secondary_ips = conf_content['APPVIEWX_DB_SECONDARY_HOSTS'].split(',')\n        try:\n            conn = MongoClient(mongo_ip,read_preference=ReadPreference.PRIMARY)\n            conn.admin.authenticate(username,password,source=dbname) \n        except Exception:\n            for mongoip in mongo_secondary_ips:\n                try:\n                    conn = MongoClient(mongoip,read_preference=ReadPreference.PRIMARY)\n                    conn.admin.authenticate(username,password,source=dbname) \n                    break\n                except Exception:\n                    mongo_ip=mongoip\n                    continue\n            else:\n                print (json.dumps([{\"error\":\"Couldn't connect to Database\"}]))\n\n    else:\n        try:\n            host='localhost:'+conf_content['APPVIEWX_DB_PORT']\n            conn = MongoClient(host)\n            conn.admin.authenticate(username,password,source=dbname) \n        except Exception as e:\n            print (json.dumps([{\"error\":\"Couldn't connect to Database\"}]))\n\n    db = conn.workFlowDBEngine\n    dbs = conn.appviewx\n    collection =  db.workorder_details\n    collection1 = dbs.apsRequests\n    failure_flag = False\n    conflict = 0\n    final = []\n    temp = []\n    error_str = ''\n    for val in collection.find({\"workorder_status\":\"In Progress\"},{\"tasks\": 1,\"email_tags\": 1}):\n        temp = []\n        for dev_list_range in range(len(val[\"tasks\"][1][\"task_input\"][\"input_data\"][\"implementation_config\"][\"deviceList\"])):\n            temp = val[\"tasks\"][1][\"task_input\"][\"input_data\"][\"implementation_config\"][\"deviceList\"][dev_list_range][\"commands\"]\n            for val1 in temp:\n\n                for mem in final_list_of_commands:\n                    new_command_flag = False\n                    try :\n                        from_form = mem.split(\" \")\n                        from_db = val1.split(\" \")\n                    except :\n                        pass\n                    from_form = filter(None, from_form)\n                    from_db = filter(None, from_db)\n                    if (len(from_db) > 0) and (len(from_form) > 0):\n                        if (from_db[0] == from_form[0]) and (from_form[0] in {\"create\",\"modify\",\"delete\"}):\n                            if len(from_db) > 4 and len(from_form) > 4:\n                                if (from_db[2] == from_form[2]) and (from_db[2] in {\"virtual\",\"pool\",\"rule\",\"snatpool\",\"wideip\",\"server\"}):\n                                    # print \"yes\"\n                                    if from_db[1] == from_form[1] and from_db[2] == from_form[2] and from_db[3] == from_form[3]:\n                                        for val2 in collection1.find({\"workOrderIds\" : str(val[\"_id\"])}):\n                                            failure_flag = True\n                                            message = \"Conflict found : \\n\"\n                                            try:\n                                                r_id = val2[\"requestId\"]+\"\\n\"\n                                            except:\n                                                r_id = \"Not Available\"\n                                            try :\n                                                template_name = \"Template : \"+val[\"email_tags\"][\"description\"]+\"\\n\"\n                                            except:\n                                                template_name = \"Not Available\"\n                                            try:\n                                                created_by = \"Created by : \"+val[\"email_tags\"][\"requestor\"]+\"\\n\"\n                                            except:\n                                                created_by = \"Not Available\"\n                                            req_id = \"Request ID : \"+r_id\n                                            # error_str += message+req_id+\"Config : \"+val1\n                                            error_str += message+template_name+created_by+req_id+\"Config : \"+val1+\"\\n\\n\"\n                                            new_command_flag = True\n                                            break\n                                            # output = {field_id_of_validate_across_workorder : error_str}\n                                            # final.append(error_str)\n                                            # print json.dumps({\"error\":\"Work order with similar object(s) exists\",\"data\":final})\n                                    if new_command_flag == True:\n                                        break\n                                    \n\n                                if (from_db[2] == from_form[2]) and (from_db[2] in {\"persistence\",\"profile\",\"monitor\"}):\n                                    if from_db[1] == from_form[1] and from_db[2] == from_form[2] and from_db[3] == from_form[3] and from_db[4] == from_form[4]:\n                                        for val2 in collection1.find({\"workOrderIds\" : str(val[\"_id\"])}):\n                                            failure_flag = True\n                                            message = \"Conflict found :\\n\"\n                                            try:\n                                                r_id = val2[\"requestId\"]+\"\\n\"\n                                            except:\n                                                r_id = \"Not Available\"\n                                            try :\n                                                template_name = \"Template : \"+val[\"email_tags\"][\"description\"]+\"\\n\"\n                                            except:\n                                                template_name = \"Not Available\"\n                                            try:\n                                                created_by = \"Created by : \"+val[\"email_tags\"][\"requestor\"]+\"\\n\"\n                                            except:\n                                                created_by = \"Not Available\"\n                                            req_id = \"Request ID : \"+r_id\n                                            # error_str += message+req_id+\"Config : \"+val1\n                                            error_str += message+template_name+created_by+req_id+\"Config : \"+val1+\"\\n\\n\"\n                                            new_command_flag = True\n                                            break\n                                            # output = {field_id_of_validate_across_workorder : error_str}\n                                            # final.append(error_str)\n                                            # print json.dumps({\"error\":\"Work order with similar object(s) exists\",\"data\":final})\n                                    if new_command_flag == True:\n                                        break\n\n    if failure_flag == True:\n        error_str = \"Work-order Check Failed \\n\"+error_str\n        final.append({field_id_of_validate_across_workorder : error_str})\n        print (json.dumps({\"error\":\"Work order with similar object(s) exists...\",\"data\":final}))\n    else:      \n        output = {\"work_order_check\" : \"Success, No Conflicts Found\"}\n        final.append(output)\n        print (json.dumps({\"message\":\"No pending work order(s) exists\",\"data\":final}))\n        return\ndef return_ssi_url(environment, device_name):\n    '''\n    returns the SSI URL based on the Environment and Device Name\n    '''\n    # if environment == \"Test\":\n    #     return \"nus-richmond-ml2.bankofamerica.com\"\n    # else:\n    connect_db = appviewx.db_connection()\n    db = connect_db.appviewx\n    try:\n        url = db.collection.find_one({\"device_name\":device_name,'collectionName':'qip_url_mapping'},{\"ssi_url\": 1})[\"ssi_url\"]\n    except TypeError:\n        return False\n    if url not in (False,\"\"):\n        return url.rstrip(\".\")\n    else:\n        return False\n\ndef create_asm_policy(asm_policy_name, device_name):\n    \"\"\"Return create asm command and ltm policy command.\n    \"\"\"\n    db = connect_db.appviewx\n    collection = db.device\n    cmd = []\n\n    device_version = str(collection.find_one({'name': device_name}, {'version': 1})['version'])\n    detailed_version = collection.find_one({'name': device_name}, {'detailedVersion': 1})['detailedVersion']\n    try:\n        tmos_version =collection.find_one({\"name\": device_name}, {'tmosVersion': 1})['tmosVersion'].split(\"-\")[0]\n    except  Exception:\n        tmos_version = None\n    if device_version in ['v12'] and detailed_version.split()[0] > \"12.0.0\":\n        if tmos_version and tmos_version not in ('11.4.1','11.4.3'):\n            cmd.append(\"create cli transaction\")\n        cmd.append(\"create asm policy \"+asm_policy_name+\" { active policy-template asm_parent_policy } \")\n        cmd.append(\"create ltm policy Drafts/\"+asm_policy_name+\" controls add { asm } requires add { http }  rules add { default { actions add { 1 { asm enable policy \"+ asm_policy_name+ \" } } ordinal 1 }  } strategy first-match\")\n        if tmos_version and tmos_version not in ('11.4.1','11.4.3'):\n            cmd.append(\"submit cli transaction\")\n        cmd.append(\"publish ltm policy Drafts/\"+asm_policy_name)\n        \n    else:\n        if tmos_version and tmos_version not in ('11.4.1','11.4.3'):\n            cmd.append(\"create cli transaction\")\n        cmd.append(\"create asm policy \"+asm_policy_name+\" { active policy-template asm_parent_policy } \")\n        cmd.append(\"create ltm policy \"+asm_policy_name+\" controls add { asm } requires add { http }  rules add { default { actions add { 1 { asm enable policy \"+ asm_policy_name+ \" } } ordinal 1 }  } strategy first-match\")\n        if tmos_version and tmos_version not in ('11.4.1','11.4.3'):\n            cmd.append(\"submit cli transaction\")\n    return cmd\n    \ndef get_config_data_of_vip(device_name, vip_name):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    device_id = fetchDeviceID(device_name)\n    for val in collection.find({\"name\":vip_name,\"deviceId\":device_id,\"code\":\"vs\"}):\n        return val[\"configData\"]\n        \ndef associate_asm_to_vip(device_name, asm_policy_name, vip, temp_type=\"create\"):\n    \"\"\"Return create asm command and ltm policy command.\n    \"\"\"\n    cmd = []\n    if temp_type == \"create\":\n        cmd.append(\"modify ltm virtual \"+vip+\" profiles add { websecurity } security-log-profiles add { bac_std_log_illegal_request } policies add { \"+asm_policy_name+\" }\")    \n    else:\n        config_data = get_config_data_of_vip(device_name, vip)\n        security_log = \" security-log-profiles add { bac_std_log_illegal_request } \" if \"security-log-profiles\" not in config_data or \"bac_std_log_illegal_request\" not in config_data else \"\"\n        web_str = \" profiles add { websecurity } \" if \"websecurity\" not in config_data else \"\"\n        cmd.append(\"modify ltm virtual \"+vip+\" \"+web_str+\" policies add { \"+asm_policy_name+\" } \"+ security_log)\n    return cmd\n\ndef get_asm_configdata_db(device_name, vip_name):\n    db = connect_db.appviewx\n    collection = db.me_adc\n    policy_name = \"\"\n    vs_config_data = None  \n    coll_dev = db.device\n    device_id = str(coll_dev.find_one({'name': device_name}, {'_id': 1})['_id'])\n    vs_config = collection.find_one({\"name\":vip_name,\"deviceId\":device_id,\"code\":\"vs\"},{\"configData\":1,\"_id\":0})  \n    vs_config_data = vs_config[\"configData\"]\n    return vs_config_data\n\n\ndef deassociate_asm_frm_vip(device_name, asm_policy_name, vip_name):\n    cmd = []\n    config_data = get_config_data_of_vip(device_name, vip_name)\n    \n    security_log = \"\"\n    websecurity_str = \"\"\n    if \"security-log-profiles\" not in config_data:\n        security_log = \" security-log-profiles none \"\n    elif \"security-log-profiles\" in config_data and \"bac_std_log_illegal_request\" not in config_data:\n        security_log = \" security-log-profiles delete {  bac_std_log_illegal_request } \" \n    if \"websecurity\" not in config_data:   \n        websecurity_str = \"  profiles delete { websecurity } \" \n    policy_str = \"  policies delete { \"+asm_policy_name+\" } \" \n    \n    cmd.append(\"modify ltm virtual \"+vip_name+policy_str+ security_log+websecurity_str)\n    cmd.append(\"delete ltm policy \"+asm_policy_name)\n    cmd.append(\"delete asm policy \"+asm_policy_name)\n    return cmd\n\ndef add_vip_description(commands_list, ait_no, db=None, device_name=None, vip_name=None, rollback=False, web_socket='No', action='CREATE'):\n    \"\"\"Add description value create ltm virtual command\n    \"\"\"\n    cmd_list = []\n    web_socket_cmd = ' :Websockets' if web_socket == 'Yes' else ''\n    if action == 'CREATE':\n        #Add description to all create ltm virtual commands\n        for cmd in commands_list:\n            if 'create ltm virtual' in cmd:\n                cmd_list.append(cmd + ' description \"AIT:' + ait_no + web_socket_cmd + '\"')\n            else:\n                cmd_list.append(cmd)\n    else:\n        if rollback == False:\n            ait_cmd = 'AIT:' + ait_no\n        else:\n            device_id = str(db.device.find_one({'name': device_name}, {'_id': 1})['_id'])\n            ait_cmd = db.me_adc.find_one({'deviceId': device_id, 'code': 'vs', 'name': vip_name}, {'description': 1})['description']\n        desc_added = False\n        #Add description to last modify ltm virtual command\n        for cmd in commands_list[::-1]:\n            #Reverse the command list to find last modify vip command\n            if (cmd.startswith('modify ltm virtual')) and (not desc_added) and (ait_cmd):\n                cmd_list.append(cmd + ' description \"' + ait_cmd + web_socket_cmd + '\"')\n                desc_added = True\n            else:\n                cmd_list.append(cmd)\n        #Revert back to original order of commands\n        cmd_list = cmd_list[::-1]\n    return cmd_list\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"createVIPHelper","_keywords":["createVIPHelper","","Version 2.x"]}