{"name":"DNSInfobloxMXRecord","scriptType":"Python","scriptContent":"'''\n------------------------------------------------------\nTask Description :\n------------------------------------------------------\nThis task is used to create, modify and delete MX record in Infloblox DNS device. It supports assigning Hostname (name + zone) to,\n\n��        Mail Exchanger Name\nVendor, Version Support :\n------------------------------------------------------\nVendor : Infoblox\nVersion : Version: 7.3.4-322642\n------------------------------------------------------\nTask Version : v1.0\nTask Type : Leaf Task\nExecution Type : Immediate and Deferred\nChecksum : f19b879a7905dbb790d845240d1f36b9\n'''\nimport ast\n\nimport re\nimport requests\nimport json\nimport time\nimport traceback\nimport sys\nimport logger_util\n\n\nsys.path.insert(0,AVX::HELPER)\nsys.path.insert(0,AVX::DEPENDENCIES)\nimport infoblox_helper as infoblox\nimport Decrypt_Python3 as Decrypt\nfrom requests.auth import HTTPBasicAuth\nfrom base64 import b64encode\nimport oob_task_utility\nimport oob_constants\nfrom DNSInfoblox import DNSInfoblox\n\nlogger = logger_util.get_logger('DNS Infoblox MX record')\n\nnull = None\n\n# DNSInfobloxMXRecord - This class handles the MX record Creation along with its rollback\nclass DNSInfobloxMXRecord(DNSInfoblox):\n\n    list_of_fields_for_clean = [    \n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.PROPOSED_NAME,\n                                    DNSInfoblox.ZONE,\n                                    DNSInfoblox.PROPOSED_ZONE,\n                                    DNSInfoblox.VIEW,\n                                    DNSInfoblox.MAIL_EXCHANGER,\n                                    DNSInfoblox.PROPOSED_MAIL_EXCHANGER,\n                                    DNSInfoblox.COMMENT,\n                                    DNSInfoblox.CREATOR,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.DDNS_PRINCIPAL\n                                ]\n    list_of_fields_for_create_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.MAIL_EXCHANGER\n                                ]\n    list_of_fields_for_delete_modify_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.MAIL_EXCHANGER\n                                ]\n\n    @classmethod\n    def validate_fields_create_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n        return status,failure_field\n\n    @classmethod\n    def validate_fields_delete_and_modify_for_specific_record_type(self,input_dict):\n        return self.validate_fields_create_for_specific_record_type(input_dict)\n\n    def __init__(self, input_dict):\n        logger.info(\"Creating Object with input :\"+str(input_dict))\n        self.name                           = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.NAME)\n        self.proposed_name                  = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_NAME)\n        self.zone                           = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ZONE)\n        self.proposed_zone                  = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_ZONE)\n        self.view                           = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.VIEW)\n        self.mail_exchanger                 = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.MAIL_EXCHANGER)\n        self.proposed_mail_exchanger        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_MAIL_EXCHANGER)\n        self.preference                     = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PREFERENCE)\n        self.comment                        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.COMMENT)\n        self.is_disable                     = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IS_DISABLE)\n        self.creator                        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CREATOR)\n        self.ddns_principal                 = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PRINCIPAL)\n        self.ddns_protected                 = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PROTECTED)\n        self.extattrs                       = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.EXTATTRS)\n        self.forbid_reclamation             = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.FORBID_RECLAMATION)\n        self.ttl                            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.TTL)\n        self.use_ttl                        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_TTL)\n\n        self.device_name                    = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.DEVICE_NAME) \n        self.device_ip                      = infoblox.get_device_ip(self.device_name)\n        \n        self.api_version                    = infoblox.get_device_version(self.device_name)\n       \n        username,password                   = Decrypt.getpassword(self.device_name)\n        self.device_user_name               = username\n        self.device_password                = password\n\n        self.is_rollback                    = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_ROLLBACK) \n        self.rollback_input                 = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.ROLLBACK_INPUT)\n        self.is_deferred_execution          = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_DEFERRED_EXECUTION)\n        self.record_type                    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.RECORD_TYPE)\n\n    #Method to Prevalidate for MX record Creation\n    def prevalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1},False)\n\n    #Method to Postvalidate for MX record Creation\n    def postvalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1},True)\n\n    def postvalidate_modify(self):\n        validation_name = ( self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name )+'.'+( self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone)\n        validation_mail_exchanger = self.proposed_mail_exchanger if self.proposed_mail_exchanger!=None and self.proposed_mail_exchanger!=\"\" else self.mail_exchanger\n        return super().validate_record({DNSInfoblox.NAME:validation_name,DNSInfoblox.MAIL_EXCHANGER:validation_mail_exchanger,\"_return_as_object\":1},True)\n\n    #Method to execute immediate MX record creation\n    def create_immediate(self):\n        logger.info(\"Creation Immediate Started\")\n        request_dict = self.get_request_dict_for_record_creation()\n        output = {}\n        try:\n            response = requests.post(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n            response_json = response.json()\n            logger.info(\"MX record Creation Response :\"+str(response_json))\n\n            if oob_constants.RESULT in response_json and DNSInfoblox.MAIL_EXCHANGER in response_json[oob_constants.RESULT]:\n                self.mail_exchanger = response_json[oob_constants.RESULT][DNSInfoblox.MAIL_EXCHANGER]\n            logger.info(\"self.mail_exchanger : \"+str(self.mail_exchanger))\n\n            #Check Error in a_record_create_response\n            isAlreadyExists = \"Error\" in response_json and \"already exists\" in str(response_json[\"Error\"])\n            \n            if isAlreadyExists:\n                logger.info(\"Record Already Exists\")\n                raise Exception(\"Record Already Exists\")\n            elif \"Error\" in response_json:\n                raise Exception(str(response_json[\"Error\"]))\n            \n            input_dict = self.__dict__\n            input_dict[DNSInfoblox.MAIL_EXCHANGER] = self.mail_exchanger\n\n            output[oob_constants.STATUS] = oob_constants.SUCCESS\n            self.add_record_type_specific_fields(output)            \n            output[oob_constants.ROLLBACK] = input_dict\n\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            logger.info(\"Exception received \"+str(exception))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            # Rollback for failure scenario\n            self.delete_immediate()\n\n        return output\n\n    #Method to execute delete MX record immediate\n    def delete_immediate(self):\n        output =  super().delete_immediate({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1})\n        if oob_constants.STATUS in output and output[oob_constants.STATUS]==oob_constants.SUCCESS:\n            self.add_record_type_specific_fields(output)            \n        return output\n    \n    #Method to execute delete MX record deferred\n    def delete_deferred(self):\n        output = super().delete_deferred({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1})        \n        self.add_record_type_specific_fields(output)        \n        return output\n\n    #Method to execute prepare rest for delete partial rollback\n    def delete_partial_rollback(self):\n        logger.info(\"Inside delete_partial_rollback :\")\n        return super().delete_partial_rollback_rest({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_type\":\"json-pretty\"})\n\n\n    def modify_immediate(self):\n        logger.info(\"Implement immediate started\")\n        output = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.MAIL_EXCHANGER+','+DNSInfoblox.PREFERENCE+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                response = requests.put(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n                response_json = response.json()\n                logger.info(\"MX record modification response :\"+str(response_json))\n                if \"Error\" in response_json:\n                    raise Exception(str(response_json[\"Error\"]))\n                #backup the changed properties\n                if not self.is_rollback:\n                    rollback_data = {}\n                    record_response_dict = record_response[oob_constants.RESULT][0];\n                    modified_dict = request_dict[oob_constants.PAYLOAD];\n                    rollback_data = {x:record_response_dict[x] for x in record_response_dict if x in modified_dict} \n                    rollback_input_dict = self.build_modify_rollback_input(rollback_data, request_dict[oob_constants.PAYLOAD])\n                    output[oob_constants.ROLLBACK] = rollback_input_dict\n\n                name = self.name if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_name\n                zone = self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_zone\n                fqdn = self.name+\".\"+self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.NAME]\n                mail_exchanger = self.mail_exchanger if DNSInfoblox.MAIL_EXCHANGER not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.MAIL_EXCHANGER]\n\n                output[oob_constants.STATUS] = oob_constants.SUCCESS\n                output[DNSInfoblox.NAME] = name\n                output[DNSInfoblox.ZONE] = zone\n                output[DNSInfoblox.FQDN] = fqdn\n                output[DNSInfoblox.MAIL_EXCHANGER] = mail_exchanger\n                self.add_record_type_specific_fields(output)\n                return output\n            else:\n                raise Exception(\"Error in fetching the MX record. MX record was not found in device\")\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during modify operation\")    \n            return output\n\n    #Rollback Not supported\n    def modify_deferred(self):\n        logger.info(\"Implement deferred - generating commands started\")\n        rest = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.MAIL_EXCHANGER:self.mail_exchanger,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.MAIL_EXCHANGER+','+DNSInfoblox.PREFERENCE+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                rest[oob_constants.DEVICE_NAME] = self.device_name\n                rest[oob_constants.HEADERS] = self.get_authorization_dict()\n                rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n                rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n                rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD]\n            else:\n                logger.info(\"Error in fetching the MX record\")\n                raise Exception(\"Error in fetching the MX record. MX record was not found in device\")\n            \n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n        self.add_record_type_specific_fields(output)\n        return output\n\n    # Method to modify MX record\n    def get_request_dict_for_record_modification(self,record_reference):\n        logger.info(\"Triggered modify MX record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/'+record_reference+'?_return_fields=name,mail_exchanger&_return_as_object=1'\n        payload = {}\n        logger.info(\"type of ttl :\"+str(type(self.ttl)))\n        if (self.proposed_name!=None and self.proposed_name!=self.name ) or (self.proposed_zone!=None and self.proposed_zone!=self.zone):\n            payload_name =(self.proposed_name if self.proposed_name else self.name)+'.'+(self.proposed_zone if self.proposed_zone else self.zone)\n            self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.NAME,payload_name)        \n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.MAIL_EXCHANGER,self.proposed_mail_exchanger)\n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.PREFERENCE,self.preference)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"MX record Modify Payload : \"+str(json.dumps(payload)))\n        logger.info(\"MX record Modify Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'PUT'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    # Method to create MX record\n    def get_request_dict_for_record_creation(self):\n        logger.info(\"Triggered Create MX record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/record:'+self.record_type+'?_return_fields=name,mail_exchanger&_return_as_object=1'\n        payload = {}\n        \n        #Mandatory\n        payload[DNSInfoblox.NAME] = self.name+\".\"+self.zone\n        payload[DNSInfoblox.PREFERENCE] = self.preference\n\n        logger.info(\"self.mail_exchanger\"+str(self.mail_exchanger))\n        \n        # Handle mail_exchanger for creating the records\n        if self.mail_exchanger != None and self.mail_exchanger != \"\":    \n            logger.info(\"mail_exchanger received : \"+self.mail_exchanger)\n            payload[DNSInfoblox.MAIL_EXCHANGER] = self.mail_exchanger\n\n        #Optional\n        self.addFieldIfNotNone(payload,DNSInfoblox.VIEW,self.view)\n        self.addFieldIfNotNone(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNone(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNone(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNone(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNone(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"MX record Creation Payload : \"+str(json.dumps(payload)))\n        logger.info(\"MX record Creation Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'POST'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    #function to assign the values for rollback\n    def build_delete_rollback_input(self,record_response):\n        rollback_input_dict = {}\n\n        list_of_fields_for_rollback_input_dict_generation = [\n                                                                DNSInfoblox.NAME,\n                                                                DNSInfoblox.ZONE,\n                                                                DNSInfoblox.VIEW,\n                                                                DNSInfoblox.MAIL_EXCHANGER,\n                                                                DNSInfoblox.PREFERENCE,\n                                                                DNSInfoblox.COMMENT,\n                                                                DNSInfoblox.CREATOR,\n                                                                DNSInfoblox.IS_DISABLE,\n                                                                DNSInfoblox.DDNS_PRINCIPAL,\n                                                                DNSInfoblox.DDNS_PROTECTED,\n                                                                DNSInfoblox.EXTATTRS,\n                                                                DNSInfoblox.FORBID_RECLAMATION,\n                                                                DNSInfoblox.TTL,\n                                                                DNSInfoblox.USE_TTL\n                                                            ]\n        \n        for field_name in list_of_fields_for_rollback_input_dict_generation:\n            rollback_input_dict[field_name]                     = oob_task_utility.getKeyValueIfAvailable(record_response,field_name)\n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = True \n\n        return rollback_input_dict\n\n    #function to assign the values for rollback\n    def build_modify_rollback_input(self,current_device_values,modify_payload):\n        rollback_input_dict = {}\n       \n        rollback_input_dict[DNSInfoblox.PROPOSED_NAME]      = self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name\n        rollback_input_dict[DNSInfoblox.PROPOSED_ZONE]      = self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone\n        rollback_input_dict[DNSInfoblox.PROPOSED_MAIL_EXCHANGER]  = self.returnFieldValueIfNotNone(DNSInfoblox.MAIL_EXCHANGER,current_device_values, modify_payload) if DNSInfoblox.MAIL_EXCHANGER not in  modify_payload else modify_payload[DNSInfoblox.MAIL_EXCHANGER]\n        \n        list_of_field_names_for_rollback_input_dict = [\n                                                        DNSInfoblox.VIEW,\n                                                        DNSInfoblox.PREFERENCE,\n                                                        DNSInfoblox.COMMENT,\n                                                        DNSInfoblox.CREATOR,\n                                                        DNSInfoblox.DISABLE,\n                                                        DNSInfoblox.DDNS_PRINCIPAL,\n                                                        DNSInfoblox.DDNS_PROTECTED,\n                                                        DNSInfoblox.EXTATTRS,\n                                                        DNSInfoblox.FORBID_RECLAMATION,\n                                                        DNSInfoblox.TTL,\n                                                        DNSInfoblox.USE_TTL\n                                                    ]\n\n        for property_field in list_of_field_names_for_rollback_input_dict:\n            #rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n            # Value from current_device_values only if both dict has key in it\n            property_field_value = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)\n            \n            if property_field in DNSInfoblox.default_value_dict and ( property_field_value==None or property_field_value==''):\n                property_field_value = DNSInfoblox.default_value_dict[property_field]\n\n            if property_field_value!=None and property_field_value!='':\n                rollback_input_dict[property_field] = property_field_value\n            #To handle int or bool field_type in case of empty or None from Device\n            elif property_field in DNSInfoblox.properties_data_type:\n                if (property_field_value is None or property_field_value == '') and (DNSInfoblox.properties_data_type[property_field] != 'int' or DNSInfoblox.properties_data_type[property_field] != 'bool'):\n                    rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[DNSInfoblox.MAIL_EXCHANGER]               = self.mail_exchanger\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = self.is_rollback\n        rollback_input_dict[DNSInfoblox.RECORD_TYPE]            = self.record_type\n\n        return rollback_input_dict\n    \n    def add_basic_fields_from_object_to_dict(self,output):\n        output[DNSInfoblox.NAME]                   = self.name\n        output[DNSInfoblox.ZONE]                   = self.zone\n        output[oob_constants.DEVICE_NAME]          = self.device_name    \n        output[oob_constants.IS_DEFERRED_EXECUTION]          = self.is_deferred_execution\n        output[oob_constants.ROLLBACK_INPUT]       = self.rollback_input\n\n    def add_record_type_specific_fields(self,output):\n        output[DNSInfoblox.MAIL_EXCHANGER] = self.mail_exchanger\n        output[DNSInfoblox.NAME] = self.name\n        output[DNSInfoblox.ZONE] = self.zone\n        output[DNSInfoblox.FQDN] = self.name+\".\"+self.zone\n\n    # Method for swapping the object identifier,to handle the change in the name of the identifier\n    def modify_swap(self):\n        if self.is_rollback:\n            if self.name != self.proposed_name and self.proposed_name != None:\n                self.name, self.proposed_name = self.proposed_name, self.name\n            if self.zone != self.proposed_zone and self.proposed_zone != None:\n                self.zone, self.proposed_zone = self.proposed_zone, self.zone\n            if self.mail_exchanger != self.proposed_mail_exchanger and self.proposed_mail_exchanger != None:\n                self.mail_exchanger, self.proposed_mail_exchanger = self.proposed_mail_exchanger, self.mail_exchanger","description":"DNSInfobloxMXRecord","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":{"committed":true,"pendingForPushAction":true,"pushActionCompleted":false,"enabledForRemoteRepository":true,"connectedRepo":null},"_id":"DNSInfobloxMXRecord","_keywords":["DNSInfobloxMXRecord","Version 3.x"]}