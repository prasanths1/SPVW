{"name":"cert_windows_noniis_push","scriptType":"Python","scriptContent":"#!Python/bin/python\nimport base64\nimport json\nimport sys\n\nfrom OpenSSL import crypto\nimport requests\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\nimport pfx_to_pem as ptp\n\npush_details= {}\npolicy = {\n\"POWERSHELL\" : 1,\n\"WMI\" : 2\n}\n\ndef decode_input(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store).decode(\"utf-8\")\n        return data_store\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \" + str(e))\n        data_store = \"error\"\n        return data_store\n\ndef decode_input_pem(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store).decode(\"utf-8\")\n        pem_file=ptp.pfx_2_pem(json.loads(data_store))\n        return data_store,pem_file\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \"+str(e))\n        data_store = \"error\"\n        return data_store\n\ndef frame_push_details(data_store):\n    \n    if \"userPreference\" in data_store[\"applicationConnector\"].keys() and \"fileProperties\" in  data_store[\"applicationConnector\"][\"userPreference\"].keys():\n        extract_push_details(data_store[\"applicationConnector\"][\"userPreference\"][\"fileProperties\"])\n    else:\n        raise Exception(\"Push location/ certificate name can't be empty\")\n\ndef extract_push_details(userProps):\n    global push_details\n    push_details[\"pfxPassword\"] =userProps[\"pfxPassword\"]\n    push_details[\"certificateFileName\"] =  userProps[\"certificateFileName\"]\n    if \"intermediateCertificateFileName\" in userProps.keys() and userProps[\"intermediateCertificateFileName\"] != None:\n      push_details[\"intermediateCertificateFileName\"] = userProps[\"intermediateCertificateFileName\"]\n    else:\n      push_details[\"intermediateCertificateFileName\"] = []\n    if \"rootCertificateFileName\" in userProps.keys() and userProps[\"rootCertificateFileName\"] != None:\n      push_details[\"rootCertificateFileName\"] = userProps[\"rootCertificateFileName\"]\n    else:\n      push_details[\"rootCertificateFileName\"] = \"\"\n\ndef get_cert_push_url(data_store):\n    \"\"\"Parse the decoded text to json and get the target machine and agent ip details\"\"\"\n    \n    frame_push_details(data_store)\n    agent_ip=data_store['vendorAuth'][\"agentUrl\"]\n    url = agent_ip + '/rest/PushCertificate'\n    return url\n\n\ndef cert_push_api(url, payload, pem_file=None):\n    \"\"\"push certificate by given payload\"\"\"\n    header = {\"Content-Type\":\"application/json\"}\n    if pem_file:\n      raw_response = requests.post(url, data=json.dumps(payload), headers=header, verify=False, cert=pem_file)\n    else:\n      raw_response = requests.post(url, data=json.dumps(payload), headers=header, verify=False)\n    return raw_response.status_code, raw_response.json()\n\n    \ndef pfx_bundle(data_store, password):    \n    cert = crypto.load_certificate(crypto.FILETYPE_PEM, data_store['certificateFile']['content'])\n    privkey = crypto.load_privatekey(crypto.FILETYPE_PEM, data_store['privateKeyFile']['content'])\n    pfx = crypto.PKCS12()\n    pfx.set_privatekey(privkey)\n    pfx.set_certificate(cert)\n    return base64.b64encode(pfx.export(password)).decode('utf-8')\n\n\nif __name__ == '__main__':\n    # try:\n    data_store,pem_file = decode_input_pem(sys.argv[1])\n    data_store=json.loads(data_store)\n    url = get_cert_push_url(data_store)\n    #password = base64.b64decode(push_details[\"pfxPassword\"]).decode('utf-8')\n    password=\"appviewx\"\n    target_machine = str(data_store['vendorAuth']['vendorDetails']['machineHostname'])\n    selected_policy = data_store['vendorAuth'][\"vendorDetails\"]['anythingElse']['windowsGateway']['type']\n    if data_store['rootCertificateFile'] != None and  data_store['rootCertificateFile']['content'] != \"\":\n        root_payload = {\n              \"UserName\":data_store['vendorAuth']['username'],\n              \"UserPassword\":data_store['vendorAuth']['authPassword'],\n              \"Policy\": policy[selected_policy],\n              \"TargetMachineName\": target_machine,\n              \"CertificateData\":  data_store['rootCertificateFile']['content'].replace(\"-----BEGIN CERTIFICATE-----\", '').replace(\"-----END CERTIFICATE-----\", '').replace(\"\\n\", '').replace(\"\\r\", ''),\n              \"StoreName\":\"Root\",\n              \"Password\": \"\",\n              \"FileName\":push_details[\"rootCertificateFileName\"],\n              \"ContainsPrivateKey\": False\n            }\n        cert_push_api(url, root_payload, pem_file)\n    if data_store['intermediateCertFiles'] != None and len(data_store['intermediateCertFiles']) != 0:\n      index_counter = 0\n      for avx_file in data_store['intermediateCertFiles']:\n        if avx_file != None and 'content' in avx_file and avx_file['content']!= \"\":\n          intermediate_payload = {\n              \"UserName\":data_store['vendorAuth']['username'],\n              \"UserPassword\":data_store['vendorAuth']['authPassword'],\n              \"Policy\": policy[selected_policy],\n              \"TargetMachineName\": target_machine,\n              \"CertificateData\":  avx_file['content'].replace(\"-----BEGIN CERTIFICATE-----\", '').replace(\"-----END CERTIFICATE-----\", '').replace(\"\\n\", '').replace(\"\\r\", ''),\n              \"StoreName\":\"CertificateAuthority\",\n              \"Password\": \"\",\n              \"FileName\": push_details[\"intermediateCertificateFileName\"][index_counter] if index_counter < len(push_details[\"intermediateCertificateFileName\"]) else \"\",\n              \"ContainsPrivateKey\": False\n            }\n        index_counter = index_counter + 1\n    else:\n        intermediate_payload = None\n    server_payload = {\n          \"UserName\":data_store['vendorAuth']['username'],\n          \"UserPassword\":data_store['vendorAuth']['authPassword'],\n          \"Policy\": policy[selected_policy],\n          \"TargetMachineName\": target_machine,\n          \"CertificateData\":  pfx_bundle(data_store, password),\n          \"StoreName\":\"\",\n          \"Password\": password,\n          \"FileName\":push_details[\"certificateFileName\"].replace('.pfx', ''),\n          \"ContainsPrivateKey\": True\n        }\n    if intermediate_payload:\n        status_code, response_json = cert_push_api(url, intermediate_payload, pem_file)\n        if status_code != 200 or \"ErrorCode\" in response_json:\n            raise Exception(\"intermediateCertificateFile Push Failure: \" + str(response_json))\n    status_code, response_json = cert_push_api(url, server_payload, pem_file)\n    if status_code == 200 and \"ErrorCode\" not in response_json:\n        print(\"AppResponseCode:0\")\n    else:\n        raise Exception(\"certificateFile Push Failure: \" + str(response_json))\n    # except Exception as e:\n    #     print(\"AppResponseCode:1\")\n    #     print(\"\\nERROR : \" + str(e))\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"cert_windows_noniis_push","_keywords":["cert_windows_noniis_push","","Version 2.x"]}