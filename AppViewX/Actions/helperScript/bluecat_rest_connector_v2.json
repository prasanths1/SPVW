{"name":"bluecat_rest_connector_v2","scriptType":"Python","scriptContent":"\n'''\nCreated on 28-Jun-2016\n\n@author: bakthavatchalam.g\n'''\nimport os\nimport sys\nimport re\nimport json\nsys.path.append(AVX::DEPENDENCIES)\nsys.path.append(AVX::HELPER)\nimport datetime\nimport requests\nimport urllib\nimport subprocess\nfrom logger_util import get_logger\n\n\nlogger = get_logger('Bluecat REST Connector::')\n\n\nclass BlueCat(object):\n    \"\"\"Blue cat SOAP connector class\n    \"\"\"\n\n    def __init__(self, ip, username, password):\n        \"\"\"Constructor that establishes connection to the device\n\n        :param str ip: Ip of the device\n        :param str username: Username\n        :param str password: Password\n        \"\"\"\n        self.ip = ip\n        self.base_url = 'https://' + self.ip + '/Services/REST/v1/'\n        self.username = username\n        self.password = password\n        self.token = None\n        self.login()\n\n    def validate_token(self):\n        \"\"\"Renews the token upon expiration of the same.\n        Validity of the token is 5 mins\n        \"\"\"\n        timestamp = datetime.datetime.now() - datetime.timedelta(minutes=5)\n        if timestamp > self.last_issued_timestamp:\n            # Token Expired. Getting new token\n            self.login()\n\n    def _parse_property(self, value):\n        \"\"\"Parse the given string of pipe separated values and return a dict\n        \"\"\"\n        dct = {}\n        for item in value.split('|'):\n            if item:\n                dct[item.split('=')[0]] = item.split('=')[1]\n        return dct\n\n\n    def login(self):\n        \"\"\"Authenticates the  API and assign the token, header values\n        \"\"\"\n        cred = {'username': self.username, 'password': self.password}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'login?' + urllib.parse.urlencode(cred))\n        curl_cmd = \"curl -k --silent -X GET '\" + self.base_url +  \"login?\" + urllib.parse.urlencode(cred) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            logger.debug(\"Response Obtained :: \" + str(response))\n            self.token = ' '.join(response.split()[2:4])\n            self.last_issued_timestamp = datetime.datetime.now()\n            self.curl_headers = \"-H 'Authorization:\" + self.token + \"' \" + \"-H 'Content-Type:application/json'\"\n            logger.info(\"cURL HEADER: \"+self.curl_headers)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n            raise Exception(\"Authorization Failure\")\n        \n    def get_entity_by_name(self,parentId,name,type):\n        \"\"\"\n        \"\"\"\n        self.validate_token()\n        data = dict(parentId=parentId, name=name, type=type)\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getEntityByName?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getEntityByName?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        \n    \n    def search_keyword_from_object_type(self,keyword,obj_type):\n        \"\"\"Get all the available configurations from the device\n        \n        returns: List of dicts\n        \"\"\"\n        self.validate_token()\n        data = dict(keyword=keyword, types=obj_type, start=0, count=10)\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'searchByObjectTypes?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"searchByObjectTypes?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_configurations(self):\n        \"\"\"Get all the available configurations from the device\n        \n        returns: List of dicts\n        \"\"\"\n        self.validate_token()\n        data = dict(parentId=0, type='Configuration', start=0, count=10)\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getEntities?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getEntities?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_views(self, configuration_id):\n        \"\"\"Get the views based on the given configuration id\n        \n        param int configuration_id: Id of the configuration\n        returns: List of dicts of views\n        \"\"\"\n        self.validate_token()\n        data = dict(parentId=configuration_id, type='View', start=0, count=10)\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getEntities?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getEntities?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_subnet_from_server_ip(self, configuration_id, app_ip):\n        \"\"\"Given a server ip, it fetches the subnet of the IP from the IPAM device\n\n        :param int configuration_id: Id of the base configuration\n        :param str app_ip: Ip of the application server\n        :returns: Subnet\n        \"\"\"\n        self.validate_token()\n        data = {'containerId': configuration_id, 'address': app_ip, 'type': 'IP4Network'}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getIPRangedByIP?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getIPRangedByIP?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                dct = self._parse_property(response['properties'])\n                dct.update(response)\n                return dct\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_free_ip_from_subnet(self, subnet_id):\n        \"\"\"Given a server ip, it finds the corresponding subnet and returns a free ip from the subnet\n\n        :param str subnet_id: Ip of the subnet\n        :returns: Free ip from the subnet \n        \"\"\"\n        self.validate_token()\n        data = {'parentId': subnet_id}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getNextAvailableIP4Address?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getNextAvailableIP4Address?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            logger.debug(status)\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def create_host_record(self, view_id, fqdn, ip):\n        \"\"\"Given a fqdn and ip, create a A record\n\n        :param int view_id: Id of the view\n        :param str fqdn: FQDN\n        :param str ip: Ip of the virtual\n        \"\"\"\n        self.validate_token()\n        data = {'viewId': view_id, 'properties': 'reverseRecord=true', 'addresses': ip, 'absoluteName': fqdn, 'ttl': 10}\n        logger.info(\"Requesting Url :: \"  + self.base_url +  'addHostRecord?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X POST \" + self.curl_headers + \" '\" + self.base_url +  \"addHostRecord?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def create_alias_record(self, view_id, name, linked_name):\n        \"\"\"Given an alias and the fqdn, creates a C record\n\n        :param int view_id: Id of the view\n        :param str name: Name of the alias\n        :param str linked_name: FQDN\n        \"\"\"\n        self.validate_token()\n        data = {'viewId': view_id, 'properties': '', 'linkedRecordName': linked_name, 'absoluteName': name, 'ttl': 10}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'addAliasRecord?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X POST \" + self.curl_headers + \" '\" + self.base_url +  \"addAliasRecord?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def unreserve_ip_address(self, configuration_id, ip):\n        '''\n        Delete all records in the reserved IP\n\n        :param int configuration_id: Id of the configuration\n        :param ip: ip address\n        '''\n        self.validate_token()\n        data = {'containerId': configuration_id, 'address': ip}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getIP4Address?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getIP4Address?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                data = {'objectId': response['id']}\n                curl_cmd = \"curl -k --silent -X DELETE \" + self.curl_headers + \" '\" + self.base_url +  \"delete?\" + urllib.parse.urlencode(data) + \"'\"\n                status, response = subprocess.getstatusoutput(curl_cmd)\n                if status:\n                    logger.exception(\"Invalid Response::\" + response)\n                else:\n                    return\n                raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_network_subnet(self, configuration_id):\n        '''Get all the available subnets in bluecat IPAM\n\n        param int configuration_id: Id of the configuration\n        '''\n        pat = re.compile('\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d+')\n        subnet_list = []\n        subnet_dict = {}\n        self.validate_token()\n        data = {'containerId': configuration_id, 'start': 0, 'count': 10}\n        logger.info(\"Requesting Url :: \"  + self.base_url +  'getIP4NetworksByHint?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getIP4NetworksByHint?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.info(\"Response Obtained :: \" + str(response))\n                for nw in response:\n                    prop = nw['properties']\n                    subnet_id = nw['id']\n                    cat = pat.search(prop)\n                    subnet_dict[cat.group()] = subnet_id\n                    subnet_list.append(cat.group())\n                return subnet_list, subnet_dict\n\n            except:\n                logger.info(\"Invalid Response::\" + response)\n        else:\n            logger.info(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def dhcp_reservation(self, configuration_id, ip, action):\n        '''\n        Given an unallocated IP, changing it to STATIC,or RESERVED,or DHCP RESERVED\n        \n        :param int configuration_id: Id of the base configuration\n        :param str ip: ip address\n        :param str action: MAKE_STATIC, MAKE_RESERVED, MAKE_DHCP_RESERVED \n        '''\n        self.validate_token()\n        data = {\"configurationId\": configuration_id, \"ip4Address\": ip, \"action\": action}\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'assignIP4Address?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X POST \" + self.curl_headers + \" '\" + self.base_url +  \"assignIP4Address?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        \n    def delete(self, id):\n        \"\"\"\n        \"\"\"\n        data = {'objectId': id}\n        curl_cmd = \"curl -k --silent -X DELETE \" + self.curl_headers + \" '\" + self.base_url +  \"delete?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if status:\n            logger.exception(\"Invalid Response::\" + response)\n        else:\n            return\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        \n    def get_host_records_by_hint(self, fqdn):\n        \"\"\"\n        \"\"\"\n        self.validate_token()\n        data = dict(start=0, count=10, options='hint={0}'.format(fqdn))\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getHostRecordsByHint?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getHostRecordsByHint?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n    def get_linked_entities(self, entity_id, _type):\n        \"\"\"\n        \"\"\"\n        self.validate_token()\n        data = dict(start=0, count=10, entityId=entity_id, type=_type)\n        logger.debug(\"Requesting Url :: \"  + self.base_url +  'getLinkedEntities?' + urllib.parse.urlencode(data))\n        curl_cmd = \"curl -k --silent -X GET \" + self.curl_headers + \" '\" + self.base_url +  \"getLinkedEntities?\" + urllib.parse.urlencode(data) + \"'\"\n        status, response = subprocess.getstatusoutput(curl_cmd)\n        if not status:\n            try:\n                response = json.loads(response)\n                logger.debug(\"Response Obtained :: \" + str(response))\n                return response\n            except:\n                logger.exception(\"Invalid Response::\" + response)\n        else:\n            logger.exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n        raise Exception(\"Failed to process request:: \" + curl_cmd + \"\\n\" + response)\n\n\n    def get_cname_records(self, fqdn):\n        \"\"\"\n        \"\"\"\n        cname_record_ids = []\n        host_record = self.get_host_records_by_hint(fqdn)\n        if host_record:\n            linked_items = self.get_linked_entities(host_record[0]['id'], 'RecordWithLink')\n            for link in linked_items:\n                if link['type'] == 'AliasRecord':\n                    cname_record_ids.append(link['id'])\n        return cname_record_ids\n\n\n# if __name__ == \"__main__\":\n#     bc = BlueCat('192.168.42.240', 'appviewx', 'appviewx')\n#     configs = bc.get_configurations()\n#     views = bc.get_views(configs[0]['id'])\n#     #print bc.get_subnet_from_server_ip(configs[0]['id'], \"1.1.1.54\")\n#     #print bc.get_free_ip_from_subnet(100927)\n#     #print bc.create_host_record(101593, \"pdc.fdc.com\", \"1.1.1.52\")\n#     print bc.unreserve_ip_address(configs[0]['id'], \"1.1.1.52\")\n#     #print bc.get_network_subnet(100881)\n#     #print bc.dhcp_reservation(100881, \"1.1.1.52\", \"MAKE_STATIC\")\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"bluecat_rest_connector_v2","_keywords":["bluecat_rest_connector_v2","","Version 2.x"]}