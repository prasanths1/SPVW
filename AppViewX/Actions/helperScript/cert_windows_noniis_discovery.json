{"name":"cert_windows_noniis_discovery","scriptType":"Python","scriptContent":"#!Python/bin/python\n\nimport base64\nimport codecs\nimport datetime\nimport hashlib\nimport json\nimport re\nimport textwrap\nimport subprocess\nimport sys\nimport time\n\nfrom OpenSSL import crypto\nfrom cryptography import x509\nfrom cryptography.hazmat.backends import default_backend\nfrom cryptography.hazmat.primitives import serialization\nimport requests\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\nimport pfx_to_pem as ptp\n\nresponse = {}\nerrorString = \"\"\nush_locations = {}\nvendor_auth =  {}\nresponse[\"certificateList\"] = []\nresponse[\"messages\"] =[]\nresponse[\"rootIntermediateList\"] = []\ndiscovery_dict = {}\nuuid_list = []\nduplicate_counter=0\nresponse[\"contentList\"] = []\nresponse[\"applicationConnectors\"]=[]\ncertificateAuthenticationDict = {\n\"1.3.6.1.5.5.7.3.18\":\"CAPWAP AC\",\n\"1.3.6.1.5.5.7.3.19\":\"CAPWAP WTP\",\n\"1.3.6.1.5.5.7.3.12\":\"SCVP Responder\",\n\"1.3.6.1.5.5.7.3.13\":\"EAP Over PPP\",\n\"1.3.6.1.5.5.7.3.10\":\"DVCS\",\n\"1.3.6.1.5.5.7.3.11\":\"SBGP Certificate AA Server Authentication\",\n\"1.3.6.1.5.5.7.3.16\":\"SCVP Client\",\n\"1.3.6.1.5.5.7.3.17\":\"IPSec IKE\",\n\"1.3.6.1.5.5.7.3.14\":\"EAP Over LAN\",\n\"1.3.6.1.5.5.7.3.15\":\"SCVP Server\",\n\"1.3.6.1.5.5.7.3.5\":\"IPSec End System\",\n\"1.3.6.1.5.5.7.3.6\":\"IPSec Tunnel\",\n\"1.3.6.1.5.5.7.3.7\":\"IPSec User\",\n\"1.3.6.1.5.5.7.3.8\":\"Time Stamping\",\n\"1.3.6.1.5.5.7.3.1\":\"Server Authentication\",\n\"1.3.6.1.5.5.7.3.2\":\"Client Authentication\",\n\"1.3.6.1.5.5.7.3.3\":\"Code Signing\",\n\"1.3.6.1.4.1.311.10.3.1\":\"Certificate trust list signing\",\n\"1.3.6.1.5.5.7.3.4\":\"Email Protection\",\n\"1.3.6.1.4.1.311.10.3.4\":\"Microsoft Encrypted File System\",\n\"1.3.6.1.4.1.311.10.3.3\":\"Microsoft Server Gated Crypto (SGC)\",\n\"2.16.840.1.113730.4.1\":\"Netscape SGC\",\n\"1.3.6.1.5.5.7.3.9\":\"OCSP Signing\",\n\"1.3.6.1.4.1.311.20.2.2\":\"Smart Card Logon\",\n\"2.16.840.1.113733.1.8.1\":\"VeriSign Server Gated Crypto (SGC)\"\n}\n\nissuingTemplateDict = {\n\"1.3.6.1.4.1.311.21.8.779229.4364248.5260208.9825147.6862436.26.2422521.15050657\" : \"TeleTech User exportable v2\",\n\"1.3.6.1.4.1.311.21.8.9988521.11120394.14369442.2024444.12371783.122.11857786.868709\" : \"Web Server\",\n\"1.3.6.1.4.1.311.21.8.9988521.11120394.14369442.2024444.12371783.122.1.30\" : \"Workstation\"\n}\n\npolicy = {\n\"POWERSHELL\" : 1,\n\"WMI\" : 2\n}\n\n\ndef decode_input(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store).decode(\"utf-8\")\n        return data_store\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \" + str(e))\n        data_store = \"error\"\n        return data_store\n\ndef decode_input_pem(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store)\n        pem_file=ptp.pfx_2_pem(json.loads(data_store))\n        return data_store,pem_file\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \"+str(e))\n        data_store = \"error\"\n        return data_store\n\ndef get_values(data_store):\n    \"\"\"Parse the decoded text to json and get the target machine and agent ip details\"\"\"\n    try:\n        initialize_resposne(data_store)\n        global vendor_auth\n        vendor_auth = data_store['vendorAuth']\n        name = str(data_store['vendorAuth']['vendorDetails']['machineHostname'])\n        windows_gateway_url = data_store['vendorAuth'][\"agentUrl\"]\n        selected_policy = data_store['vendorAuth'][\"vendorDetails\"]['anythingElse']['windowsGateway']['type']\n        url = windows_gateway_url + '/rest/DiscoverCertificates'\n        payload = {\n            \"UserName\":data_store['vendorAuth']['username'],\n            \"UserPassword\":data_store['vendorAuth']['authPassword'],\n            \"Policy\": policy[selected_policy],\n            \"TargetMachineName\": name,\n            \"IncludeBinaryData\": True,\n            \"IncludePrivateKey\": False,\n            \"Mode\": 2,\n            \"Start\": 0,\n            \"Limit\": 1000\n        }\n        return url, payload\n    except Exception as e:\n        print(str(e))\n        return url, payload\n\n\ndef initialize_resposne(data_store):\n    response[\"requestUuid\"]=str(data_store[\"requestUuid\"])\n    response[\"requestName\"]=str(data_store[\"requestName\"])\n    response[\"recursive\"]=str(data_store[\"recursive\"])\n    response[\"scheduled\"]=str(data_store[\"scheduled\"])\n    if \"discoveryId\" in data_store:\n        response[\"discoveryId\"] = data_store[\"discoveryId\"]\n    response[\"vendorInfo\"] = {}\n    response[\"vendorInfo\"][\"deviceName\"] = str(data_store[\"vendorAuth\"][\"vendorDetails\"][\"name\"])\n    response[\"vendorInfo\"][\"category\"] = str(data_store[\"vendorAuth\"][\"vendorDetails\"][\"category\"])\n    response[\"vendorInfo\"][\"vendor\"] = str(data_store[\"vendorAuth\"][\"vendorDetails\"][\"vendor\"])\n    response[\"vendorInfo\"][\"certSyncStatus\"] = str(data_store[\"vendorAuth\"][\"vendorDetails\"][\"certSyncStatus\"])\n\n\ndef discovery_api(url, payload, pem_file=None):\n    \"\"\"Validate the target machine\"\"\"\n    header = {\"Content-Type\":\"application/json\"}\n    response_code = ''\n    try:\n        if pem_file:\n            raw_response = requests.post(url, data=json.dumps(payload), headers=header, verify=False, cert=pem_file)\n        else:\n            raw_response = requests.post(url, data=json.dumps(payload), headers=header, verify=False)\n        response_code = raw_response\n        raw_response_data = json.loads(raw_response.text)\n        return raw_response_data, response_code\n    except Exception as e:\n        print(\"\\nERROR : \\n\" + str(e))\n        raw_response_data = \"No response\"\n        return raw_response_data, response_code\n\n\ndef print_pem(bin_cert, cert_type):\n\n    if not (\"PRIVATE KEY\" in bin_cert or \"CERTIFICATE\" in bin_cert):\n        content = \"-----BEGIN \" + cert_type + \"-----\\n\"\n        content_value = \"\\r\\n\".join(textwrap.wrap(bin_cert, 64))\n        content = content + content_value\n        content = content + \"\\n-----END \" + cert_type + \"-----\"\n    else:\n        content = bin_cert.decode(\"utf-8\")\n    return content\n\n\ndef get_cert_details(data):\n    cert = crypto.load_certificate(crypto.FILETYPE_PEM, data)\n    return cert\n\n\ndef set_validity(certificate):\n    validtill = time.mktime(certificate.not_valid_after.timetuple()) - time.timezone\n    validfrom = time.mktime(certificate.not_valid_before.timetuple()) - time.timezone\n    discovery_dict['validFrom'] = int(validfrom * 1000)\n    discovery_dict['validUntil'] = int(validtill * 1000)\n\n\ndef set_version_and_validity(certificate):\n    discovery_dict[\"version\"] = int(certificate.version.name.strip(\"v\"))\n    set_validity(certificate)\n\n\ndef set_status(certificate):\n    status = \"Valid\"\n    validUntill = certificate.not_valid_after.date()\n    today = datetime.date.today()\n    diff_in_days = (validUntill - today).days\n    if diff_in_days < 0:\n        status = \"Expired\"\n    elif diff_in_days < 10 :\n        status = \"Expiry in 10 Days\"\n    elif diff_in_days < 30 :\n        status = \"Expiry in 30 Days\"\n    elif diff_in_days < 90 :\n        status = \"Expiry in 90 Days\"\n    discovery_dict[\"status\"] = status\n\n\ndef get_public_key_info(certificate):\n    encoding = serialization.Encoding.DER\n\n    pub = certificate.public_key()\n    discovery_dict[\"publicKeyInfo\"] = {}\n    keyType = \"\"\n    pubType = str(type(pub))\n    if \"RSAPublic\" in pubType:\n        keyType = \"RSA\"\n    elif \"DSAPublic\" in pubType:\n        keyType = \"DSA\"\n    elif \"EllipticCurve\" in pubType:\n        keyType = \"EC\"\n    pubFormat = serialization.PublicFormat.PKCS1 if keyType == \"RSA\" else serialization.PublicFormat.SubjectPublicKeyInfo\n    discovery_dict[\"publicKeyInfo\"][\"keyAlgorithm\"] = keyType\n    discovery_dict[\"publicKeyInfo\"][\"publicKey\"] = butify(codecs.encode(pub.public_bytes(encoding, pubFormat), 'hex').decode(\"utf-8\"))\n    discovery_dict[\"publicKeyInfo\"][\"bitLength\"] = pub.curve.key_size if keyType == \"EC\" else pub.key_size\n\n\ndef get_serial_number(cert):\n    sno = cert.get_serial_number()\n    sno = hex(sno)\n    sno = sno.upper()[2:]\n    serial_no = butify(sno)\n    # serial_no = ':'.join(a+b for a,b in zip(sno, sno))\n    discovery_dict[\"serialNumber\"] = serial_no\n    return serial_no\n\n\ndef get_signature_algorithm(cert):\n    discovery_dict[\"extension\"] = {}\n    algorithm = cert.get_signature_algorithm().decode(\"utf-8\")\n    algorithm = algorithm.replace('Encryption', '')\n    keys = ['sha', 'rsa']\n    for i in keys:\n        algorithm = re.sub(i, i.upper(), algorithm)\n    discovery_dict[\"extension\"][\"signatureAlgorithm\"] = algorithm\n    discovery_dict[\"extension\"][\"signatureHashAlgorithm\"] = algorithm.split(\"With\")[0]\n    discovery_dict[\"extension\"][\"thumbprintAlgorithm\"] = \"SHA-1\"\n    discovery_dict[\"extension\"][\"thumbPrint\"] = cert.digest(\"sha1\").decode(\"utf-8\")\n\n\ndef get_subject_details(cert):\n    subject = cert.get_subject()\n    subList = [str(key.decode(\"utf-8\") + \"=\" + value.decode(\"utf-8\")) for key, value in subject.get_components()]\n    subList.reverse()\n    discovery_dict[\"subject\"] = \", \".join(subList)\n    discovery_dict[\"state\"] = get_empty_if_none(subject.ST)\n    discovery_dict[\"organization\"] = get_empty_if_none(subject.O)\n    discovery_dict[\"country\"] = get_empty_if_none(subject.C)\n    discovery_dict[\"location\"] = get_empty_if_none(subject.L)\n    discovery_dict[\"commonName\"] = get_empty_if_none(subject.CN)\n    discovery_dict[\"mailAddress\"] = get_empty_if_none(subject.emailAddress)\n    discovery_dict[\"division\"] = get_empty_if_none(subject.OU)\n\n\ndef get_issuer_details(cert):\n    issuer = cert.get_issuer()\n    discovery_dict[\"issuer\"] = {}\n    discovery_dict[\"issuer\"][\"state\"] = get_empty_if_none(issuer.ST)\n    discovery_dict[\"issuer\"][\"organization\"] = get_empty_if_none(issuer.O)\n    discovery_dict[\"issuer\"][\"country\"] = get_empty_if_none(issuer.C)\n    discovery_dict[\"issuer\"][\"location\"] = get_empty_if_none(issuer.L)\n    discovery_dict[\"issuer\"][\"commonName\"] = get_empty_if_none(issuer.CN)\n    discovery_dict[\"issuer\"][\"division\"] = get_empty_if_none(issuer.OU)\n    return issuer.CN\n\n\ndef get_empty_if_none(val):\n    return \"\" if val == None else str(val)\n\n\ndef generate_uuid():\n    serial_no = str(discovery_dict[\"serialNumber\"])\n    shaObject = hashlib.sha1()\n    shaObject.update((serial_no + discovery_dict[\"issuer\"][\"commonName\"]).encode())\n    return shaObject.hexdigest()\n\n\ndef set_cert_content(content, keyContent=None):\n    c = {}\n    c[\"certificateContent\"] = content\n    c[\"privateKey\"] = keyContent\n    c[\"uuid\"] = discovery_dict[\"uuid\"]\n    response[\"contentList\"].append(c)\n\n\ndef convert_individual_cert_content(content):\n    global errorString\n    try:\n        global discovery_dict\n        global uuid_list\n        discovery_dict = {}\n        cert = get_cert_details(content)\n        get_issuer_details(cert)\n        get_subject_details(cert)\n        get_serial_number(cert)\n        get_signature_algorithm(cert)\n        frame_extensions_and_public_key(str(content))\n        frame_key_usage(cert)\n        discovery_dict[\"uuid\"] = generate_uuid()\n        discovery_dict[\"category\"] = getCategory()\n        if discovery_dict[\"uuid\"] not in uuid_list:\n            uuid_list.append(discovery_dict[\"uuid\"])\n            set_cert_content(content)\n            if discovery_dict[\"category\"] in [\"Server\",\"Client\",\"Others\"] :\n                response[\"certificateList\"].append(discovery_dict)\n                frame_and_add_applicationConnector()\n            else:\n                response[\"rootIntermediateList\"].append(discovery_dict)\n        else:\n            global duplicate_counter\n            duplicate_counter = duplicate_counter + 1\n    except Exception as e:\n        errorString=errorString+\"Error while parsing certificate \\n\"+ str(e)+\"\\n\\n\\n\"\n\n\ndef frame_and_add_applicationConnector():\n    applicationConnector = {}\n    applicationConnector[\"_id\"] = vendor_auth[\"vendorDetails\"][\"name\"] + \":@\" + discovery_dict[\"uuid\"]\n    applicationConnector[\"certificateUuid\"] = discovery_dict[\"uuid\"]\n    applicationConnector[\"syncInfo\"]= {}\n    applicationConnector[\"syncInfo\"][\"syncMessage\"] = get_status_message(\"Discovery\",\"SUCCESS\",\"Profile is in sync\")\n    applicationConnector[\"syncInfo\"][\"syncStatus\"] =\"SYNCRONIZED\"\n    applicationConnector[\"profileInfo\"] ={}\n    applicationConnector[\"profileInfo\"][\"_id\"] = applicationConnector[\"_id\"]\n    applicationConnector[\"profileInfo\"][\"profileIdentifier\"] =vendor_auth[\"vendorDetails\"][\"name\"]\n    applicationConnector[\"profileInfo\"][\"vendor\"] = vendor_auth[\"vendorDetails\"][\"vendor\"]\n    applicationConnector[\"profileInfo\"][\"deviceName\"] = vendor_auth[\"vendorDetails\"][\"name\"]\n    applicationConnector[\"profileInfo\"][\"vendorCategory\"] = vendor_auth[\"vendorDetails\"][\"category\"]\n    applicationConnector[\"profileInfo\"][\"connectorType\"] = \"DEFAULT_CONNECTOR\" \n    applicationConnector[\"profileInfo\"][\"vendorProperties\"] = {}\n    applicationConnector[\"profileInfo\"][\"vendorProperties\"][\"certificateType\"] = \"PEM-.crt\"\n    applicationConnector[\"profileInfo\"][\"vendorProperties\"][\"certificateFileName\"]=\"certificate.crt\"\n    applicationConnector[\"profileInfo\"][\"vendorProperties\"][\"rootCertificateFileName\"]=\"\"\n    applicationConnector[\"profileInfo\"][\"vendorProperties\"][\"intermediateCertificateFileName\"]=\"\"\n    applicationConnector[\"profileInfo\"][\"overviewData\"] = {} \n    response[\"applicationConnectors\"].append(applicationConnector)\n\n\ndef get_status_message(title,status,message):\n    status_message = {}\n    status_message[\"title\"] = title\n    status_message[\"status\"] = status\n    status_message[\"message\"] = message\n    return status_message\n\n\ndef getCategory():\n    isCaCertificate = isCACertificate()\n    if isCaCertificate:\n        if discovery_dict[\"commonName\"] == discovery_dict[\"issuer\"][\"commonName\"]:\n            return \"Root CA\"\n        return \"Intermediate CA\"\n    elif \"extendedKeyUsage\" not in discovery_dict[\"extension\"].keys() :\n        return \"Others\"\n    elif \"Server\" in discovery_dict[\"extension\"][\"extendedKeyUsage\"]:\n        return \"Server\"\n    elif \"Client\" in discovery_dict[\"extension\"][\"extendedKeyUsage\"]:\n        return \"Client\"\n    return \"Others\"\n\n\ndef isCACertificate():\n    isVersionOneCertificate = discovery_dict[\"version\"] == 1\n    isHavingBasicConstraints = \"basicConstraints\" in discovery_dict[\"extension\"].keys() and discovery_dict[\"extension\"][\"basicConstraints\"][\"subjectType\"] == \"CA\"\n    isHavingEmptyCommonName = \"commonName\" not in discovery_dict.keys() or discovery_dict[\"commonName\"] == \"\"\n    isSubjectCommonNameAndIssuerCommonNameSame = discovery_dict[\"commonName\"] == discovery_dict[\"issuer\"][\"commonName\"]\n\n    if isVersionOneCertificate:\n        return isSubjectCommonNameAndIssuerCommonNameSame;\n    return isHavingBasicConstraints or isHavingEmptyCommonName\n\n\ndef frame_key_usage(cert):\n    keyUsage = \"\"\n    for index in range(0, cert.get_extension_count()):\n        if 'keyUsage' == cert.get_extension(index).get_short_name():\n            keyUsage = butify(codecs.encode(cert.get_extension(index).get_data(), 'hex'))\n    discovery_dict[\"extension\"][\"keyUsage\"] = keyUsage\n\n\ndef frame_extensions_and_public_key(content):\n    certificate = x509.load_pem_x509_certificate(content.encode(), default_backend())\n    set_version_and_validity(certificate)\n    set_status(certificate)\n    get_public_key_info(certificate)\n    discovery_dict[\"chainIdentifier\"] = {}\n    for extension in certificate.extensions:\n        key = getattr(extension.oid, \"_name\")\n        oid = str(extension.oid.dotted_string)\n        if 'authorityKeyIdentifier' == key:\n            frame_extension_authorityKeyIdentifier(extension)\n        elif 'subjectKeyIdentifier' == key:\n            digest = codecs.encode(extension.value.digest, 'hex').decode(\"utf-8\")\n            discovery_dict[\"chainIdentifier\"][\"subjectKeyIdentifier\"] = butify(digest)\n        elif 'subjectAltName' == key:\n            discovery_dict[\"subjectAlternativeNames\"] = [str(getattr(x, \"_value\")) for x in getattr((getattr(extension.value, \"_general_names\")), \"_general_names\")]\n        elif 'extendedKeyUsage' == key:\n            usageList = [str(usage.dotted_string) for usage in getattr(extension.value, \"_usages\")]\n            discovery_dict[\"extension\"][\"extendedKeyUsage\"] = \" \".join((certificateAuthenticationDict[usageoid] if usageoid in certificateAuthenticationDict else usageoid)  + \"(\" + usageoid + \")\" for usageoid in usageList)\n        elif 'certificatePolicies' == key:\n            discovery_dict[\"extension\"][\"certificatePolicies\"] = frame_certificate_policies(extension)\n        elif 'authorityInfoAccess' == key:\n            discovery_dict[\"extension\"][\"authorityInfoAccess\"] = frame_authority_info_access(extension)\n        elif 'basicConstraints' == key:\n            discovery_dict[\"extension\"][\"basicConstraints\"] = {}\n            discovery_dict[\"extension\"][\"basicConstraints\"][\"subjectType\"] = \"CA\" if extension.value.ca else  \"End entity\"\n            discovery_dict[\"extension\"][\"basicConstraints\"][\"pathLength\"] = extension.value.path_length\n        elif 'cRLDistributionPoints' == key:\n            discovery_dict[\"extension\"][\"crlDistributionPoints\"] = frame_crl_points(extension)\n        elif oid in [\"1.3.6.1.4.1.311.21.7\", \"1.3.6.1.4.1.311.20.2\"]:\n            issuingTemplate = frame_issuing_template(extension.value.value)\n            discovery_dict[\"extension\"][\"issuingTemplate\"] = issuingTemplateDict[issuingTemplate] if oid == '1.3.6.1.4.1.311.21.7' and issuingTemplate in issuingTemplateDict.keys() else issuingTemplate\n\n\ndef frame_issuing_template(extVal):\n    try:\n        command = 'echo \"\"\"' + base64.b64encode(extVal).decode('utf-8') + '\"\"\"  | openssl asn1parse'\n        _, output = subprocess.getstatusoutput(str(command))\n        return str(output.split(\"\\n\")[1].split(\"OBJECT\")[1].strip(\" :\"))\n    except Exception:\n        return \"\"\n\n\ndef frame_crl_points(extension):\n    crlPointsList = []\n    for crl in getattr(extension.value, \"_distribution_points\"):\n        name = crl.relative_name\n        for crlurl in crl.full_name:\n            crlPoint = {}\n            crlPoint[\"name\"] = name\n            crlPoint[\"url\"] = str(crlurl.value)\n            crlPointsList.append(crlPoint)\n    return crlPointsList\n\n\ndef frame_authority_info_access(extension):\n    authorityInfoAccessList = []\n    for authorityinfo in getattr(extension.value, \"_descriptions\"):\n        authorityInfoAccess = {}\n        authorityInfoAccess[\"accessMethod\"] = str(authorityinfo.access_method.dotted_string)\n        authorityInfoAccess[\"alterativeName\"] = \"\"\n        authorityInfoAccess[\"url\"] = str(authorityinfo.access_location.value)\n        authorityInfoAccessList.append(authorityInfoAccess)\n    return authorityInfoAccessList\n\n\ndef frame_certificate_policies(extension):\n    certPolicies = []\n    for policy in getattr(extension.value, \"_policies\"):\n        certificatePolicy = {}\n        certificatePolicy[\"identifier\"] = str(policy.policy_identifier.dotted_string)\n        certificatePolicy[\"name\"] = str(getattr(policy.policy_identifier, \"_name\"))\n        qualifierList = []\n        for qualifier in policy.policy_qualifiers or []:\n            certQualifier = {}\n            certQualifier[\"name\"] = str(qualifier)\n            qualifierList.append(certQualifier)\n        certificatePolicy[\"policyQualifiers\"] = qualifierList\n        certPolicies.append(certificatePolicy)\n    return certPolicies\n\n\ndef frame_extension_authorityKeyIdentifier(extension):\n    keyIdentifier = butify(codecs.encode(extension.value.key_identifier, 'hex').decode(\"utf-8\"))\n    discovery_dict[\"chainIdentifier\"][\"authorityKeyIdentifier\"] = keyIdentifier\n    if extension.value.authority_cert_serial_number == None:\n     serial_no=\"\"\n    else:\n     sno = hex(extension.value.authority_cert_serial_number)\n     sno = sno.upper()[2:]\n     serial_no = butify(sno)\n    discovery_dict[\"chainIdentifier\"][\"issuerSerialNumber\"] =  serial_no\n\n\ndef butify(val):\n    val = str(val.upper())\n    if not len(val) % 2 == 0:\n        val = \"0\" + val\n    return \":\".join([ val[i] + val[i + 1] for i in range(0, len(val), 2)])\n\n\ndef frame_response_value(success_rate):\n    \"\"\"Validation of response data to get the required output\"\"\"\n    output = \"AppResponseCode:1\"\n    if success_rate == 0:\n        output = \"AppResponseCode:0\"\n        response[\"messages\"].append(get_status_message(\"Certificate parsing\",\"SUCCESS\",\"Successfully parsed \" + str(len(response[\"certificateList\"])) + \" server certificate(s) and \" + str(len(response[\"rootIntermediateList\"])) + \"root/intermediate certificates  \" + str(duplicate_counter) + \" duplicate certificates\"))\n        return output\n    else:\n        return output\n\ndef frame_response_and_print(response_code=\"200\"):\n    response_value = frame_response_value(0)\n    final_response[\"responseCode\"] = str(response_code)\n    final_response[\"response\"] = response\n    final_response[\"responseValue\"] = response_value\n    final_response[\"errorMessage\"] = errorString\n    print(json.dumps(final_response))\n\ndef set_success_rate(key_store):\n    if key_store.certs:\n        success_rate = 0\n    else:\n        success_rate = 1\n    return success_rate\n\ndef is_pfx_content(cert_content):\n    is_pfx = False\n    data_list = cert_content[\"Data\"]\n    for key_value in data_list:\n        if \"ContentType\" == key_value.get(\"Key\",\"None\"):\n            is_pfx = (\"Pfx\" == key_value.get(\"Value\"))\n    return is_pfx\n\nif __name__ == '__main__':\n    content_values = {}\n    final_response = {}\n    content_values_list = []\n    overall_success_rate = 0\n    success_ratios = []\n    data_store = sys.argv[1]\n    data_store,pem_file = decode_input_pem(data_store)\n    try:\n        data_store = json.loads(data_store)\n    except Exception as e:\n        print(\"Unable to load json, give valid encoded input \", str(e))\n    if data_store != \"error\":\n        if str(data_store[\"certificateRequired\"]).lower() == \"true\":\n            url, payload = get_values(data_store)\n            raw_response_data, response_code = discovery_api(url, payload, pem_file)\n            if raw_response_data == \"No response\":\n                print(\"Check inputs\")\n            else:\n                for cert_content in raw_response_data[\"Certificates\"]:\n                    if is_pfx_content(cert_content):\n                        continue\n                    pem_centent = print_pem(cert_content[\"BinaryData\"], \"CERTIFICATE\")\n                    convert_individual_cert_content(pem_centent)\n                frame_response_and_print(response_code)\n        else:\n            frame_response_and_print()\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"cert_windows_noniis_discovery","_keywords":["cert_windows_noniis_discovery","","Version 2.x"]}