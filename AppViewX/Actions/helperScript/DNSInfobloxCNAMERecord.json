{"name":"DNSInfobloxCNAMERecord","scriptType":"Python","scriptContent":"'''\n------------------------------------------------------\nTask Description :\n------------------------------------------------------\nThis task is used to create CNAME Record in Infloblox DNS device. It supports assigning Hostname (name + zone) to,\n\n��     Canonical Name \n\n------------------------------------------------------\nVendor, Version Support :\n------------------------------------------------------\nVendor : Infoblox\nVersion : Version: 7.3.4-322642\n------------------------------------------------------\nTask Version : v1.0\nTask Type : Leaf Task\nExecution Type : Immediate and Deferred\nChecksum : f19b879a7905dbb790d845240d1f36b9\n'''\nimport ast\n\nimport re\nimport requests\nimport json\nimport time\nimport traceback\nimport sys\nimport logger_util\n\n\nsys.path.insert(0,AVX::HELPER)\nsys.path.insert(0,AVX::DEPENDENCIES)\nimport infoblox_helper as infoblox\nimport Decrypt_Python3 as Decrypt\nfrom requests.auth import HTTPBasicAuth\nfrom base64 import b64encode\nimport oob_task_utility\nimport oob_constants\nfrom DNSInfoblox import DNSInfoblox\n\nlogger = logger_util.get_logger('DNS Infoblox CNAME Record')\n\nnull = None\n\n# DNSInfobloxARecord - This class handles the CNAME Record Creation along with its rollback\nclass DNSInfobloxCNAMERecord(DNSInfoblox):\n\n    list_of_fields_for_clean = [    \n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.PROPOSED_NAME,\n                                    DNSInfoblox.ZONE,\n                                    DNSInfoblox.PROPOSED_ZONE,\n                                    DNSInfoblox.VIEW,\n                                    DNSInfoblox.CANONICAL,\n                                    DNSInfoblox.PROPOSED_CANONICAL,\n                                    DNSInfoblox.COMMENT,\n                                    DNSInfoblox.CREATOR,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.DDNS_PRINCIPAL\n                                ]\n    list_of_fields_for_create_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.CANONICAL\n                                ]\n    list_of_fields_for_delete_modify_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.CANONICAL\n                                ]\n\n    @classmethod\n    def validate_fields_create_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n        return status,failure_field\n\n    @classmethod\n    def validate_fields_delete_and_modify_for_specific_record_type(self,input_dict):\n        return self.validate_fields_create_for_specific_record_type(input_dict)\n\n    def __init__(self, input_dict):\n        logger.info(\"Creating Object with input :\"+str(input_dict))\n        self.name                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.NAME)\n        self.proposed_name          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_NAME)\n        self.zone                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ZONE)\n        self.proposed_zone          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_ZONE)\n        self.view                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.VIEW)\n        self.canonical               = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CANONICAL)\n        self.proposed_canonical      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_CANONICAL)\n        self.comment                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.COMMENT)\n        self.is_disable             = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IS_DISABLE)\n        self.creator                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CREATOR)\n        self.ddns_principal         = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PRINCIPAL)\n        self.ddns_protected         = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PROTECTED)\n        self.extattrs               = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.EXTATTRS)\n        self.forbid_reclamation     = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.FORBID_RECLAMATION)\n        self.ttl                    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.TTL)\n        self.use_ttl                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_TTL)\n\n        self.device_name            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.DEVICE_NAME) \n        self.device_ip              = infoblox.get_device_ip(self.device_name)\n        \n        self.api_version            = infoblox.get_device_version(self.device_name)\n       \n        username,password           = Decrypt.getpassword(self.device_name)\n        self.device_user_name       = username\n        self.device_password        = password\n\n        self.is_rollback            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_ROLLBACK) \n        self.rollback_input         = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.ROLLBACK_INPUT)\n        self.is_deferred_execution            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_DEFERRED_EXECUTION)\n        self.record_type            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.RECORD_TYPE)\n\n    #Method to Prevalidate for CNAME Record Creation\n    def prevalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1},False)\n\n    #Method to Postvalidate for CNAME Record Creation\n    def postvalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1},True)\n\n    def postvalidate_modify(self):\n        validation_name = ( self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name )+'.'+( self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone)\n        validation_canonical = self.proposed_canonical if self.proposed_canonical!=None and self.proposed_canonical!=\"\" else self.canonical\n        return super().validate_record({DNSInfoblox.NAME:validation_name,DNSInfoblox.CANONICAL:validation_canonical,\"_return_as_object\":1},True)\n\n    #Method to execute immediate CNAME Record creation\n    def create_immediate(self):\n        logger.info(\"Creation Immediate Started\")\n        request_dict = self.get_request_dict_for_record_creation()\n        output = {}\n        try:\n            response = requests.post(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n            response_json = response.json()\n            logger.info(\"CNAME Record Creation Response :\"+str(response_json))\n\n            if oob_constants.RESULT in response_json and DNSInfoblox.CANONICAL in response_json[oob_constants.RESULT]:\n                self.canonical = response_json[oob_constants.RESULT][DNSInfoblox.CANONICAL]\n            logger.info(\"self.canonical : \"+str(self.canonical))\n\n            #Check Error in a_record_create_response\n            isAlreadyExists = \"Error\" in response_json and \"already exists\" in str(response_json[\"Error\"])\n            \n            if isAlreadyExists:\n                logger.info(\"Record Already Exists\")\n                raise Exception(\"Record Already Exists\")\n            elif \"Error\" in response_json:\n                raise Exception(str(response_json[\"Error\"]))\n            \n            input_dict = self.__dict__\n            input_dict[DNSInfoblox.CANONICAL] = self.canonical\n\n            output[oob_constants.STATUS] = oob_constants.SUCCESS\n            self.add_record_type_specific_fields(output)            \n            output[oob_constants.ROLLBACK] = input_dict\n\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            logger.info(\"Exception received \"+str(exception))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            # Rollback for failure scenario\n            self.delete_immediate()\n\n        return output\n\n    #Method to execute delete CNAME Record immediate\n    def delete_immediate(self):\n        output =  super().delete_immediate({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1})\n        if oob_constants.STATUS in output and output[oob_constants.STATUS]==oob_constants.SUCCESS:\n            self.add_record_type_specific_fields(output)            \n        return output\n    \n    #Method to execute delete CNAME Record deferred\n    def delete_deferred(self):\n        output = super().delete_deferred({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1})        \n        self.add_record_type_specific_fields(output)        \n        return output\n\n    #Method to execute prepare rest for delete partial rollback\n    def delete_partial_rollback(self):\n        logger.info(\"Inside delete_partial_rollback :\")\n        return super().delete_partial_rollback_rest({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_type\":\"json-pretty\"})\n\n\n    def modify_immediate(self):\n        logger.info(\"Implement immediate started\")\n        output = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.CANONICAL+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                response = requests.put(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n                response_json = response.json()\n                logger.info(\"CNAME Record modification response :\"+str(response_json))\n                if \"Error\" in response_json:\n                    raise Exception(str(response_json[\"Error\"]))\n                #backup the changed properties\n                if not self.is_rollback:\n                    rollback_data = {}\n                    record_response_dict = record_response[oob_constants.RESULT][0];\n                    modified_dict = request_dict[oob_constants.PAYLOAD];\n                    rollback_data = {x:record_response_dict[x] for x in record_response_dict if x in modified_dict} \n                    rollback_input_dict = self.build_modify_rollback_input(rollback_data, request_dict[oob_constants.PAYLOAD])\n                    output[oob_constants.ROLLBACK] = rollback_input_dict\n\n                name = self.name if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_name\n                zone = self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_zone\n                fqdn = self.name+\".\"+self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.NAME]\n                canonical = self.canonical if DNSInfoblox.CANONICAL not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.CANONICAL]\n\n                output[oob_constants.STATUS] = oob_constants.SUCCESS\n                output[DNSInfoblox.NAME] = name\n                output[DNSInfoblox.ZONE] = zone\n                output[DNSInfoblox.FQDN] = fqdn\n                output[DNSInfoblox.CANONICAL] = canonical\n                self.add_record_type_specific_fields(output)\n                return output\n            else:\n                raise Exception(\"Error in fetching the CNAME Record. CNAME Record was not found in device\")\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during modify operation\")    \n            return output\n\n    #Rollback Not supported\n    def modify_deferred(self):\n        logger.info(\"Implement deferred - generating commands started\")\n        rest = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,DNSInfoblox.CANONICAL:self.canonical,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.CANONICAL+','+DNSInfoblox.COMMENT+','+DNSInfoblox.DISABLE+','+DNSInfoblox.CREATOR+','+DNSInfoblox.DDNS_PRINCIPAL+','+DNSInfoblox.DDNS_PROTECTED+','+DNSInfoblox.EXTATTRS+','+DNSInfoblox.FORBID_RECLAMATION+','+DNSInfoblox.TTL+','+DNSInfoblox.USE_TTL})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                rest[oob_constants.DEVICE_NAME] = self.device_name\n                rest[oob_constants.HEADERS] = self.get_authorization_dict()\n                rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n                rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n                rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD]\n            else:\n                logger.info(\"Error in fetching the CNAME Record\")\n                raise Exception(\"Error in fetching the CNAME Record. CNAME Record was not found in device\")\n            \n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n        self.add_record_type_specific_fields(output)\n        return output\n\n    # Method to modify CNAME Record\n    def get_request_dict_for_record_modification(self,record_reference):\n        logger.info(\"Triggered modify CNAME Record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/'+record_reference+'?_return_fields=name,canonical&_return_as_object=1'\n        payload = {}\n        logger.info(\"type of ttl :\"+str(type(self.ttl)))\n        if (self.proposed_name!=None and self.proposed_name!=self.name ) or (self.proposed_zone!=None and self.proposed_zone!=self.zone):\n            payload_name =(self.proposed_name if self.proposed_name else self.name)+'.'+(self.proposed_zone if self.proposed_zone else self.zone)\n            self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.NAME,payload_name)        \n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CANONICAL,self.proposed_canonical)\n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"CNAME Record Modify Payload : \"+str(json.dumps(payload)))\n        logger.info(\"CNAME Record Modify Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'PUT'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    # Method to create CNAME record\n    def get_request_dict_for_record_creation(self):\n        logger.info(\"Triggered Create CNAME Record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/record:'+DNSInfoblox.CNAME_RECORD_TYPE+'?_return_fields=name,canonical&_return_as_object=1'\n        payload = {}\n        \n        #Mandatory\n        payload[DNSInfoblox.NAME] = self.name+\".\"+self.zone\n\n        logger.info(\"self.canonical\"+str(self.canonical))\n        \n        # Handle canonical for creating the records\n        if self.canonical != None and self.canonical != \"\":    \n            logger.info(\"canonical received : \"+self.canonical)\n            payload[DNSInfoblox.CANONICAL] = self.canonical\n\n        #Optional\n        self.addFieldIfNotNone(payload,DNSInfoblox.VIEW,self.view)\n        self.addFieldIfNotNone(payload,DNSInfoblox.COMMENT,self.comment)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DISABLE,self.is_disable)\n        self.addFieldIfNotNone(payload,DNSInfoblox.CREATOR,self.creator)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PRINCIPAL,self.ddns_principal)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNone(payload,DNSInfoblox.EXTATTRS,self.extattrs)\n        self.addFieldIfNotNone(payload,DNSInfoblox.FORBID_RECLAMATION,self.forbid_reclamation)\n        self.addFieldIfNotNone(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"CNAME Record Creation Payload : \"+str(json.dumps(payload)))\n        logger.info(\"CNAME Record Creation Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'POST'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    #function to assign the values for rollback\n    def build_delete_rollback_input(self,record_response):\n        rollback_input_dict = {}\n\n        list_of_fields_for_rollback_input_dict_generation = [\n                                                                DNSInfoblox.NAME,\n                                                                DNSInfoblox.ZONE,\n                                                                DNSInfoblox.VIEW,\n                                                                DNSInfoblox.CANONICAL,\n                                                                DNSInfoblox.COMMENT,\n                                                                DNSInfoblox.CREATOR,\n                                                                DNSInfoblox.IS_DISABLE,\n                                                                DNSInfoblox.DDNS_PRINCIPAL,\n                                                                DNSInfoblox.DDNS_PROTECTED,\n                                                                DNSInfoblox.EXTATTRS,\n                                                                DNSInfoblox.FORBID_RECLAMATION,\n                                                                DNSInfoblox.TTL,\n                                                                DNSInfoblox.USE_TTL\n                                                            ]\n        \n        for field_name in list_of_fields_for_rollback_input_dict_generation:\n            rollback_input_dict[field_name]                     = oob_task_utility.getKeyValueIfAvailable(record_response,field_name)\n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = True \n\n        return rollback_input_dict\n\n    #function to assign the values for rollback\n    def build_modify_rollback_input(self,current_device_values,modify_payload):\n        rollback_input_dict = {}\n       \n        rollback_input_dict[DNSInfoblox.PROPOSED_NAME]      = self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name\n        rollback_input_dict[DNSInfoblox.PROPOSED_ZONE]      = self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone\n        rollback_input_dict[DNSInfoblox.PROPOSED_CANONICAL]  = self.returnFieldValueIfNotNone(DNSInfoblox.CANONICAL,current_device_values, modify_payload) if DNSInfoblox.CANONICAL not in  modify_payload else modify_payload[DNSInfoblox.CANONICAL]\n        \n        list_of_field_names_for_rollback_input_dict = [\n                                                        DNSInfoblox.VIEW,\n                                                        DNSInfoblox.COMMENT,\n                                                        DNSInfoblox.CREATOR,\n                                                        DNSInfoblox.DISABLE,\n                                                        DNSInfoblox.DDNS_PRINCIPAL,\n                                                        DNSInfoblox.DDNS_PROTECTED,\n                                                        DNSInfoblox.EXTATTRS,\n                                                        DNSInfoblox.FORBID_RECLAMATION,\n                                                        DNSInfoblox.TTL,\n                                                        DNSInfoblox.USE_TTL\n                                                    ]\n\n        for property_field in list_of_field_names_for_rollback_input_dict:\n            #rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n            # Value from current_device_values only if both dict has key in it\n            property_field_value = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)\n            \n            if property_field in DNSInfoblox.default_value_dict and ( property_field_value==None or property_field_value==''):\n                property_field_value = DNSInfoblox.default_value_dict[property_field]\n\n            if property_field_value!=None and property_field_value!='':\n                rollback_input_dict[property_field] = property_field_value\n            #To handle int or bool field_type in case of empty or None from Device\n            elif property_field in DNSInfoblox.properties_data_type:\n                if (property_field_value is None or property_field_value == '') and (DNSInfoblox.properties_data_type[property_field] != 'int' or DNSInfoblox.properties_data_type[property_field] != 'bool'):\n                    rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[DNSInfoblox.CANONICAL]               = self.canonical\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = self.is_rollback\n        rollback_input_dict[DNSInfoblox.RECORD_TYPE]            = self.record_type\n\n        return rollback_input_dict\n    \n    def add_basic_fields_from_object_to_dict(self,output):\n        output[DNSInfoblox.NAME]                   = self.name\n        output[DNSInfoblox.ZONE]                   = self.zone\n        output[oob_constants.DEVICE_NAME]          = self.device_name    \n        output[oob_constants.IS_DEFERRED_EXECUTION]          = self.is_deferred_execution\n        output[oob_constants.ROLLBACK_INPUT]       = self.rollback_input\n\n    def add_record_type_specific_fields(self,output):\n        output[DNSInfoblox.CANONICAL] = self.canonical\n        output[DNSInfoblox.NAME] = self.name\n        output[DNSInfoblox.ZONE] = self.zone\n        output[DNSInfoblox.FQDN] = self.name+\".\"+self.zone\n\n    # Method for swapping the object identifier,to handle the change in the name of the identifier\n    def modify_swap(self):\n        if self.is_rollback:\n            if self.name != self.proposed_name and self.proposed_name != None:\n                self.name, self.proposed_name = self.proposed_name, self.name\n            if self.zone != self.proposed_zone and self.proposed_zone != None:\n                self.zone, self.proposed_zone = self.proposed_zone, self.zone\n            if self.canonical != self.proposed_canonical and self.proposed_canonical != None:\n                self.canonical, self.proposed_canonical = self.proposed_canonical, self.canonical","description":"DNSInfobloxCNAMERecord","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"DNSInfobloxCNAMERecord","_keywords":["DNSInfobloxCNAMERecord","Version 3.x"]}