{"name":"cert_windows_jks_push","scriptType":"Python","scriptContent":"#!Python/bin/python\nfrom __future__ import print_function\nimport base64\nimport textwrap\nimport requests\nfrom requests.packages.urllib3.exceptions import InsecureRequestWarning\nrequests.packages.urllib3.disable_warnings(InsecureRequestWarning)\nimport json\nimport sys\nimport jks\nimport re\nimport os\nfrom OpenSSL import crypto\nimport os\nimport pdb\nimport time;\nimport pfx_to_pem as ptp\npush_details ={}\n\npolicy = {\n\"POWERSHELL\" : 1,\n\"WMI\" : 2\n}\n\ndef decode_input(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store)\n        return data_store\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \"+str(e))\n        data_store = \"error\"\n        return data_store\n\ndef decode_input_pem(data_store):\n    \"\"\"Decode the encocded request input from user\"\"\"\n    try:\n        data_store = base64.b64decode(data_store)\n        pem_file=ptp.pfx_2_pem(json.loads(data_store))\n        return data_store,pem_file\n    except Exception as e:\n        print(\"\\nThe encoded text is not valid : \"+str(e))\n        data_store = \"error\"\n        return data_store\n\ndef frame_push_details(data_store):\n    if \"userPreference\" in data_store[\"applicationConnector\"].keys() and \"fileProperties\" in  data_store[\"applicationConnector\"][\"userPreference\"].keys():\n        extract_push_details(data_store[\"applicationConnector\"][\"userPreference\"][\"fileProperties\"])\n    elif \"profileInfo\" in data_store[\"applicationConnector\"].keys() and \"vendorProperties\" in data_store[\"applicationConnector\"][\"profileInfo\"].keys():\n        extract_push_details(data_store[\"applicationConnector\"][\"profileInfo\"][\"vendorProperties\"])\n    else:\n        raise Exception(\"Push location/ certificate name can't be empty\")\n\ndef extract_push_details(userProps):\n    global push_details\n    push_details[\"pfxPassword\"] =userProps[\"pfxPassword\"]\n    push_details[\"pushLocation\"] = userProps[\"pushLocation\"]\n    push_details[\"certificateFileName\"] =  userProps[\"certificateFileName\"]\n    push_details[\"pushRootIntermediateCertificates\"] = str(userProps[\"pushRootAndIntermediateCertificates\"]).lower() if \"pushRootAndIntermediateCertificates\" in userProps else \"false\" \n\ndef get_discovery_api_values(data_store):\n    \"\"\"Parse the decoded text to json and get the target machine and agent ip details\"\"\"\n    push_locations = []\n    name = ''\n    url = ''\n    payload = ''\n\n    try:\n        frame_push_details(data_store)\n        agent_ip=data_store['vendorAuth'][\"agentUrl\"]\n        name = str(data_store['vendorAuth']['vendorDetails']['machineHostname'])\n        selected_policy = data_store['vendorAuth'][\"vendorDetails\"]['anythingElse']['windowsGateway']['type']\n        password_encrypted =  push_details[\"pfxPassword\"]\n        password = base64.b64decode(password_encrypted).decode(\"utf-8\")\n        url = agent_ip\n        cert_location = push_details[\"pushLocation\"]\n        location = (cert_location if cert_location.endswith(\"/\") or cert_location.endswith(\"\\\\\") else cert_location+\"\\\\\")+ push_details[\"certificateFileName\"]\n        location = location.replace('/','\\\\')\n        location = \"\\\\\" + location\n        location = str(location.replace(':','$'))\n        push_locations.append(location)\n        payload = {\n            \"UserName\":data_store['vendorAuth']['username'],\n            \"UserPassword\":data_store['vendorAuth']['authPassword'],\n            \"Policy\": policy[selected_policy],\n            \"TargetMachineName\": name,\n            \"PushLocations\":push_locations\n        }\n        return name, url, push_locations, password, payload\n    except Exception as e:\n        print(str(e))\n        password = ''\n        return name, url, push_locations, password, payload\n\n\ndef discovery_api(url, payload, pem_file=None):\n    \"\"\"Validate the target machine\"\"\"\n    header = {\"Content-Type\":\"application/json\"}\n    response_code = ''\n    try:\n        if pem_file:\n            raw_response = requests.post(url+'/rest/ReadMultipleFiles', data=json.dumps(payload), headers=header, verify=False, cert=pem_file) #post method to validate the url\n        else:\n            raw_response = requests.post(url+'/rest/ReadMultipleFiles', data=json.dumps(payload), headers=header, verify=False)\n        response_code = raw_response\n        with open('/tmp/response_jks_push','w') as k:\n            k.write(str(raw_response.text))\n        raw_response_data = json.loads(raw_response.text)\n        return raw_response_data, response_code\n    except Exception as e:\n        print(\"\\nERROR : \\n\"+str(e))\n        raw_response_data = \"No response\"\n        return raw_response_data, response_code\n\ndef get_discovery_file(raw_response_data):\n    \"\"\"Get discovery file already available\"\"\"\n    for value in raw_response_data[\"Files\"]:\n        file_name = str(value[\"FileName\"])\n        file_content = value[\"FileContent\"]\n    return file_content\n\ndef create_alias_name(data_store):\n    \"\"\"Create alias name to be used for the entry\"\"\"\n    subject = data_store['certificate']['subject']\n    alias_name = str(subject).lower()\n    return alias_name\n\n\ndef get_certificate_file(data_store):\n    \"\"\"Get the certificates details from data store\"\"\"\n    pk_certs = []\n    certs = []\n    pkey = ''\n    alias_name = create_alias_name(data_store)\n    if data_store['certificateFile']['content'] != \"\":\n        pk_cert_content = data_store['certificateFile']['content']\n        pk_certs.append(pk_cert_content.encode('utf-8'))\n    if data_store['privateKeyFile']['content'] != \"\":\n        pk_key_content = data_store['privateKeyFile']['content']\n        # pkeyFile=crypto.load_privatekey(crypto.FILETYPE_PEM,pk_key_content)\n        # pkey = crypto.dump_privatekey(crypto.FILETYPE_ASN1, pkeyFile)\n        pkey=pk_key_content.strip(\"-----\").split(\"-----\")[1].replace(\"\\n\",\"\").replace(\"\\r\",\"\")\n    if push_details[\"pushRootIntermediateCertificates\"] == \"true\":\n        if data_store['intermediateCertFiles'] != None and len(data_store['intermediateCertFiles']) != 0:\n            for avx_file in data_store['intermediateCertFiles']:\n                if avx_file != None and 'content' in avx_file and avx_file[\"content\"] != \"\":\n                    inter_cert_content = avx_file['content']\n                    pk_certs.append(inter_cert_content.encode('utf-8'))\n\n        if data_store['rootCertificateFile'] != None and  'content' in data_store['rootCertificateFile'] and data_store['rootCertificateFile']['content'] != \"\":\n            root_cert_content = data_store['rootCertificateFile']['content']\n            pk_certs.append(root_cert_content.encode('utf-8'))\n\n    return certs, pk_certs, pkey, alias_name\n\ndef create_trusted_cert_entries(certs, alias_name):\n    ''' Trusted cert entries '''\n    cert_list = []\n    for cert_pem in certs:\n        cert =crypto.load_certificate(crypto.FILETYPE_PEM,cert_pem)\n        # cert_bytes = cert_pem.encode('utf-8')\n        cert_bytes = crypto.dump_certificate(crypto.FILETYPE_ASN1, cert)\n        # cert_entry = jks.TrustedCertEntry.new(alias_name, cert_bytes)\n        cert_list.append(cert_bytes)\n    return cert_list\n\ndef create_private_key_entries(pk_certs, pkey, alias_name):\n    ''' Private key entries '''\n    pk_list = []\n    pk_dict = {}\n    pk_entry = jks.PrivateKeyEntry.new(alias_name, pk_certs, base64.b64decode(pkey))\n    pk_dict[alias_name] = pk_entry\n    pk_list.append(pk_entry)\n    return pk_list, pk_dict\n\ndef get_existing_cert_contents(ks):\n    '''Method to convert the cert content '''\n    entries_list = []\n    exisiting_entries = {}\n    for alias,c in ks.certs.items():\n        exisiting_entries[alias] = c\n        entries_list.append(c)\n    for alias, pk in ks.private_keys.items():\n        exisiting_entries[alias] = pk\n        entries_list.append(pk)\n    return entries_list, exisiting_entries\n\ndef merge_entries(cert_list, pk_list, exisiting_entries_list, entries_dict, pk_dict, data_store):\n    \"\"\"Merge the existig and new entries of the file\"\"\"\n    entries_list = []\n    over_write = str( data_store[\"applicationConnector\"][\"userPreference\"][\"overwrite\"] if \"userPreference\" in data_store[\"applicationConnector\"].keys() else False)\n    if over_write.lower() == \"true\":\n        for existing_key in entries_dict.keys():\n            for new_key in pk_dict.keys():\n                if existing_key == new_key:\n                    exisiting_entries_list.remove(entries_dict[existing_key])\n    else:\n        for existing_key in entries_dict.keys():\n            for new_key in pk_dict.keys():\n                if existing_key == new_key:\n                    raise Exception(\"Entry with same alias_name exists\")\n\n    entries_list = cert_list + pk_list + exisiting_entries_list\n    return entries_list\n\ndef create_keystore_entry(entries_list, password):\n\n    keystore = jks.KeyStore.new('jks',entries_list)\n    return keystore.saves(password)\n\ndef convert_byte_array(data):\n    import base64\n    return base64.b64encode(data).decode(\"utf-8\")\n\ndef delete_file(name):\n    \"\"\"Delete the temporary file created\"\"\"\n    os.remove(name)\n\ndef push_api(url, payload, pem_file=None):\n    \"\"\"Validate the target machine\"\"\"\n    header = {\"Content-Type\":\"application/json\"}\n    url = url + '/rest/WriteFile' #framing the validation url from the user input request\n    response_code = ''\n    push_response_code=\"\"\n    try:\n        #print(json.dumps(payload))\n        if pem_file:\n            raw_push_response = requests.post(url,data=json.dumps(payload),headers=header, verify=False, cert=pem_file) #post method to validate the url\n        else:\n            raw_push_response = requests.post(url,data=json.dumps(payload),headers=header, verify=False) #post method to validate the url\n        push_response_code = raw_push_response\n        raw_push_response_data = json.loads(raw_push_response.text)\n        return raw_push_response_data, push_response_code\n    except Exception as e:\n        print(\"\\nERROR : \\n\"+str(e))\n        raw_push_response_data = \"No response\"\n        return raw_push_response_data, push_response_code\n\ndef build_push_payload(data_store, name, url, push_location, content):\n    selected_policy = data_store['vendorAuth'][\"vendorDetails\"]['anythingElse']['windowsGateway']['type']\n    payload = {\n        \"UserName\":data_store['vendorAuth']['username'],\n        \"UserPassword\":data_store['vendorAuth']['authPassword'],\n        \"Policy\": policy[selected_policy],\n        \"TargetMachineName\": name,\n        \"Path\":push_location,\n        \"Content\":content\n    }\n    return payload\n\nif __name__ == '__main__':\n    data_store = sys.argv[1]\n    data_store,pem_file = decode_input_pem(data_store)\n    try:\n        data_store = json.loads(data_store)\n    except Exception as e:\n        print(\"In get_discovery_api_values, unable to load json, give valid encoded input \",str(e))\n    try:\n        name, url, push_locations, password, discovery_payload = get_discovery_api_values(data_store)\n        raw_response_data, response_code = discovery_api(url, discovery_payload, pem_file)\n        if '200' in str(response_code):\n            if raw_response_data[\"Files\"] != []:\n                file_content = get_discovery_file(raw_response_data)\n                decoded_data = decode_input(file_content)\n                key_store = jks.KeyStore.loads(decoded_data,password)\n                entries_list, entries_dict = get_existing_cert_contents(key_store)\n                certs, pk_certs, pkey, alias_name = get_certificate_file(data_store)\n                certs_list = create_trusted_cert_entries(certs, alias_name)\n                pk_list, pk_dict= create_private_key_entries(pk_certs, pkey, alias_name)\n                entries_list = merge_entries(certs_list, pk_list, entries_list, entries_dict, pk_dict, data_store)\n                content_bytes = create_keystore_entry(entries_list, password)\n                content = convert_byte_array(content_bytes)\n                payload = build_push_payload(data_store, name, url, push_locations[0], content)\n                raw_push_response_data, push_response_code = push_api(url, payload, pem_file)\n                if '200' in str(push_response_code):\n                   print(\"AppResponseCode:0\")\n                else:\n                   print(json.dumps(raw_push_response_data))\n            else:\n                entries_list=[]\n                entries_dict = {}\n                certs, pk_certs, pkey, alias_name = get_certificate_file(data_store)\n                certs_list = create_trusted_cert_entries(pk_certs, alias_name)\n                pk_list, pk_dict = create_private_key_entries(certs_list, pkey, alias_name)\n                content_bytes = create_keystore_entry(pk_list, password)\n                content = convert_byte_array(content_bytes)\n                payload = build_push_payload(data_store, name, url, push_locations[0], content)\n                print(payload)\n                raw_push_response_data, push_response_code = push_api(url, payload, pem_file)\n                if '200' in str(push_response_code):\n                   print(\"AppResponseCode:0\")\n                else:\n                   print(json.dumps(raw_push_response_data))\n    except Exception as e:\n        print(\"AppResponseCode:1\")\n        print(\"\\nERROR : \"+str(e))\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"cert_windows_jks_push","_keywords":["cert_windows_jks_push","","Version 2.x"]}