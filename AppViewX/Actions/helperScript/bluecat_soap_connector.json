{"name":"bluecat_soap_connector","scriptType":"Python","scriptContent":"'''\nCreated on 18-Oct-2016\n\n@author: bakthavatchalam.g\n'''\nimport os\nimport sys\nimport re\n#sys.path.insert(0, '/home/appviewx/AppViewX/scripts/../properties/../aps/dependencies')\n#sys.path.insert(0, '/home/appviewx/AppViewX/scripts/../properties/../aps/helper')\nsys.path.append('/home/appviewx/AppViewX/aps/dependencies')\nimport datetime\nfrom suds.client import Client\nimport logging\nlogging.basicConfig(level=logging.INFO)\nlogging.getLogger('suds.xsd.schema').setLevel(logging.DEBUG)\n\nBASE_URL = \"http://{ip}/Services/API?WSDL\"\nBASE_CONFIGURATON = \"test\"\nBASE_VIEW = \"test\"\n\n\nclass BlueCat(object):\n    \"\"\"Blue cat SOAP connector class\n    \"\"\"\n\n    def __init__(self, ip, username, password):\n        \"\"\"Constructor that establishes connection to the device\n\n        :param str ip: Ip of the device\n        :param str username: Username\n        :param str password: Password\n        \"\"\"\n        self.ip = ip\n        self.username = username\n        self.password = password\n        self.client = Client(BASE_URL.format(ip=ip))\n        self.service = self.client.service\n        self.login()\n\n    def validate_token(self):\n        \"\"\"Renews the token upon expiration of the same.\n        Validity of the token is 5 mins\n        \"\"\"\n        timestamp = datetime.datetime.now() - datetime.timedelta(minutes=5)\n        if timestamp > self.last_issued_timestamp:\n            # Token Expired. Getting new token\n            self.login()\n\n    def login(self):\n        \"\"\"Authenticates the  API\n        \"\"\"\n        self.service.login(username=self.username, password=self.password)\n        self.last_issued_timestamp = datetime.datetime.now()\n\n    def get_subnet_from_server_ip(self, app_ip):\n        \"\"\"Given a server ip, it fetches the subnet of the IP from the IPAM device\n\n        :param str app_ip: Ip of the application server\n        :returns: Subnet\n        \"\"\"\n        self.validate_token()\n        configurations = self.service.searchByObjectTypes(keyword=BASE_CONFIGURATON, types='Configuration', start=0, count=10).item\n        if configurations:\n            return self.service.getIPRangedByIP(**{'containerId': configurations[0].id, 'address': app_ip, 'type': 'IP4Network'})\n\n    def get_free_ip_from_subnet(self, subnet_id):\n        \"\"\"Given a server ip, it finds the corresponding subnet and returns a free ip from the subnet\n\n        :param str subnet_id: Ip of the subnet\n        :returns: Free ip from the subnet \n        \"\"\"\n        self.validate_token()\n        return self.service.getNextAvailableIP4Address(parentId=subnet_id)\n\n    def create_host_record(self, fqdn, ip):\n        \"\"\"Given a fqdn and ip, create a A record\n\n        :param str fqdn: FQDN\n        :param str ip: Ip of the virtual\n        \"\"\"\n        self.validate_token()\n        views = self.service.searchByObjectTypes(keyword=BASE_VIEW, types='View', start=0, count=10).item\n        if views:\n            return self.service.addHostRecord(**{'viewId': views[0].id, 'properties': 'reverseRecord=true', 'addresses': ip, 'absoluteName': fqdn, 'ttl': 10})\n\n    def create_alias_record(self, name, linked_name):\n        \"\"\"Given an alias and the fqdn, creates a C record\n\n        :param str name: Name of the alias\n        :param str linked_name: FQDN\n        \"\"\"\n        self.validate_token()\n        views = self.service.searchByObjectTypes(keyword=BASE_VIEW, types='View', start=0, count=10).item\n        if views:\n            return self.service.addAliasRecord(**{'viewId': views[0].id, 'properties': '', 'linkedRecordName': linked_name, 'absoluteName': name, 'ttl': 10})\n\n    def get_cname_records(self, fqdn):\n        \"\"\"Given a fqdn, fetches the list of ids of associated alias records\n\n        :param str fqdn: FQDN\n        \"\"\"\n        cname_record_ids = []\n        host_record = self.service.getHostRecordsByHint(start=0, count=10, options='hint={0}'.format(fqdn))\n        print host_record\n        if host_record:\n            linked = self.service.getLinkedEntities(start=0, count=10, entityId=host_record.item[0].id, type='RecordWithLink')\n            print linked\n            for link in linked.item:\n                print link\n                if link.type == 'AliasRecord':\n                    cname_record_ids.append(link.id)\n        return cname_record_ids\n\n    def unreserve_ip_address(self, ip):\n        '''\n        Delete all records in the reserved IP\n\n        :param ip: ip address\n        '''\n        self.validate_token()\n        configurations = self.service.searchByObjectTypes(keyword=BASE_CONFIGURATON, types='Configuration', start=0, count=10).item\n        if configurations:\n            ip_obj = self.service.getIP4Address(configurations[0].id, ip)\n            if ip_obj:\n                print self.service.delete(ip_obj.id)\n\n    def get_network_subnet(self):\n        '''\n        get all the available subnets in bluecat IPAM\n        '''\n        pat = re.compile('\\d+\\.\\d+\\.\\d+\\.\\d+\\/\\d+')\n        subnet_list = []\n        subnet_dict = {}\n        self.validate_token()\n        configurations = self.service.searchByObjectTypes(keyword=BASE_CONFIGURATON, types='Configuration', start=0, count=10).item\n        if configurations:\n            response = self.service.getIP4NetworksByHint(containerId=configurations[0].id, start=0, count=10)\n            for nw in response.item:\n                prop = nw.properties\n                subnet_id = nw.id\n                cat = pat.search(prop)\n                subnet_dict[cat.group()] = subnet_id\n                subnet_list.append(cat.group())\n        return subnet_list, subnet_dict\n\n","description":"","readOnly":false,"version":"Version 2.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"bluecat_soap_connector","_keywords":["bluecat_soap_connector","","Version 2.x"]}