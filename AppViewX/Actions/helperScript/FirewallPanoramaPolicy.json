{"name":"FirewallPanoramaPolicy","scriptType":"Python","scriptContent":"import sys\nimport traceback\nimport logger_util\n\nsys.path.insert(0,AVX::HELPER)\nsys.path.insert(0,AVX::DEPENDENCIES)\n\nlogger = logger_util.get_logger(\"Firewall Panorama Policy\")\n\n'''\nThis task is to create the Policy Object in the Panorama Device\n#FIXME: Prevalidation and Postvalidation to be done\n#FIXME: if no input received fro the boolean flags, then the device property is set to 'no'\n'''\n\nclass FirewallPanoramaPolicy(object):\n\n    @classmethod\n    def clean_input_data(self,input_dict):\n        logger.info(\"Input Received Before clean : \"+str(input_dict))\n\n        input_dict[\"name\"] = self.handle_strip(input_dict['name'])\n        input_dict[\"device_group\"] = self.handle_strip(input_dict['device_group'])\n        input_dict[\"action\"] = self.handle_strip(input_dict['action']).lower() if self.handle_strip(input_dict['action'])!=None else None\n        input_dict[\"service\"] = self.handle_strip(input_dict['service'])\n        input_dict[\"description\"] = self.handle_strip(input_dict['description'])\n        input_dict[\"category\"] = self.handle_strip(input_dict['category'])\n        input_dict[\"application\"] = self.handle_strip(input_dict['application'])\n        input_dict[\"tag\"] = self.handle_strip(input_dict['tag'])\n        input_dict[\"rule_type\"] = self.handle_strip(input_dict['rule_type'])\n        input_dict[\"source_user\"] = self.handle_strip(input_dict['source_user'])\n        input_dict[\"from\"] = self.handle_strip(input_dict['from'])\n        input_dict[\"to\"] = self.handle_strip(input_dict['to'])        \n        input_dict[\"source\"] = self.handle_strip(input_dict['source'])        \n        input_dict[\"destination\"] = self.handle_strip(input_dict['destination'])        \n        input_dict[\"log_setting\"] = self.handle_strip(input_dict['log_setting'])                \n        input_dict[\"hip_profiles\"] = self.handle_strip(input_dict['hip_profiles'])                \n        input_dict['device_name'] = self.handle_strip(input_dict['device_name'])\n        input_dict['operation_type'] = self.handle_strip(input_dict['operation_type'])\n                    \n\n        logger.info(\"Input Received After clean : \"+str(input_dict))\n\n    #FIXME: Only generic validation available, specific to vendor to be added\n    @classmethod\n    def validate_input_data(self,input_dict):\n        logger.info(\"Validating the Input Data\")\n        status = True\n\n        status = status and self.mandatory_string_validation(input_dict['name'],\"name\",True)        \n        status = status and self.mandatory_string_validation(input_dict['device_group'],\"device_group\",True)        \n        status = status and self.mandatory_string_validation(input_dict['source'],\"source\",True)        \n        status = status and self.mandatory_string_validation(input_dict['destination'],\"destination\",True)                \n        status = status and self.mandatory_string_validation(input_dict['device_name'],\"device_name\",True)                \n\n        if not status:\n            logger.info(\"INPUT VALIDATION FAILED\")\n        else:\n            logger.info(\"INPUT VALIDATION SUCCESS\")\n\n        return status\n\n    @classmethod\n    def validation_fail_output(self):\n        output = {}\n        output[\"status\"] = \"failed\"\n        output[\"message\"] = \"Validation failed\"\n        logger.info(\"output : \"+str(output))\n        return output\n\n    def __init__(self, input_dict):\n        logger.info(\"Creating Object with input :\"+str(input_dict))\n        self.name = input_dict[\"name\"]\n        self.device_group = input_dict[\"device_group\"]\n        self.is_log_end = input_dict[\"is_log_end\"]\n        self.is_log_start = input_dict[\"is_log_start\"]\n        self.action = input_dict[\"action\"]\n        self.service = input_dict[\"service\"]       \n        self.description = input_dict[\"description\"]\n        self.is_disabled = input_dict[\"is_disabled\"]\n        self.category = input_dict[\"category\"]\n        self.is_negate_source = input_dict[\"is_negate_source\"]\n        self.is_negate_destination = input_dict[\"is_negate_destination\"]\n        self.application = input_dict[\"application\"]\n        self.tag = input_dict[\"tag\"]\n        self.rule_type = input_dict[\"rule_type\"]\n        self.schedule = input_dict[\"schedule\"]\n        self.source_user = input_dict[\"source_user\"]\n        self.fromm = input_dict[\"from\"]\n        self.to = input_dict[\"to\"]\n        self.source = input_dict[\"source\"]\n        self.destination = input_dict[\"destination\"]\n        self.log_setting = input_dict[\"log_setting\"]\n        self.hip_profiles = input_dict[\"hip_profiles\"]\n        self.is_icmp_unreachable = input_dict[\"is_icmp_unreachable\"]\n\n        self.device_name = input_dict['device_name']\n        self.is_rollback = input_dict['is_rollback']\n        self.rollback_input = input_dict['rollback_input']\n        self.is_deferred = input_dict['is_deferred']\n\n        self.operation_type = input_dict['operation_type']\n\n    def get_input_dict(self):\n        output = {}\n        output[\"name\"] = self.name\n        output[\"device_group\"] = self.device_group\n        output[\"is_log_end\"] = self.is_log_end\n        output[\"is_log_start\"] = self.is_log_start\n        output[\"action\"] = self.action\n        output[\"service\"] = self.service\n        output[\"description\"] = self.description\n        output[\"is_disabled\"] = self.is_disabled\n        output[\"category\"] = self.category\n        output[\"is_negate_source\"] = self.is_negate_source\n        output[\"is_negate_destination\"] = self.is_negate_destination\n        output[\"application\"] = self.application\n        output[\"tag\"] = self.tag\n        output[\"rule_type\"] = self.rule_type\n        output[\"schedule\"] = self.schedule\n        output[\"source_user\"] = self.source_user\n        output[\"from\"] = self.fromm\n        output[\"to\"] = self.to\n        output[\"source\"] = self.source\n        output[\"destination\"] = self.destination\n        output[\"log_setting\"] = self.log_setting\n        output[\"hip_profiles\"] = self.hip_profiles\n        output[\"is_icmp_unreachable\"] = self.is_icmp_unreachable\n\n        output['device_name'] = self.device_name\n        output['is_rollback'] = self.is_rollback\n        output['rollback_input'] = self.rollback_input\n        output['is_deferred'] = self.is_deferred\n\n        output['operation_type'] = self.operation_type\n\n        return output\n        \n    def create(self):\n        logger.info(\"Creation Started\")\n        try:\n            if self.is_deferred:\n                return self.create_deferred()\n            else:\n                return self.create_immediate()\n        except Exception as exception:\n            output = {}\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[\"status\"] = \"failed\"\n            output[\"error\"] = str(exception)\n            output[\"error_trace\"] = str(error_trace)\n            return output\n    # FIXME: support not provided now\n    def create_immediate(self):\n        logger.info(\"Create Immediate not supported\")\n        return {\"status\":\"failed\",\"message\":\"not supported\"}\n\n    def create_deferred(self):\n        output_commands = []\n        command = \"set device-group \"+self.device_group+\" pre-rulebase security \"\n\n        command = self.extend_command_with_given_input(\"rules\",self.name,command)\n        \n        command += \"log-end \"+(\"yes\" if self.is_log_end else \"no\")+\" \"\n        command += \"log-start \"+(\"yes\" if self.is_log_start else \"no\")+\" \"\n\n        command = self.extend_command_with_given_input(\"action\",self.action,command)\n        command = self.extend_command_with_given_input(\"service\",self.service,command)\n        \n        if self.description:\n            command += \"description '\"+self.description+\"' \"\n\n\n        command += \"disabled \"+(\"yes\" if self.is_disabled else \"no\")+\" \"\n\n        command = self.extend_command_with_given_input(\"category\",self.category,command)\n\n        command += \"negate-source \"+(\"yes\" if self.is_negate_source else \"no\")+\" \"\n        command += \"negate-destination \"+(\"yes\" if self.is_negate_destination else \"no\")+\" \"\n\n        command = self.extend_command_with_given_input(\"application\",self.application,command)\n        command = self.extend_command_with_given_input(\"tag\",self.tag,command)\n        command = self.extend_command_with_given_input(\"rule-type\",self.rule_type,command)\n        command = self.extend_command_with_given_input(\"schedule\",self.schedule,command)\n        command = self.extend_command_with_given_input(\"source-user\",self.source_user,command)\n        command = self.extend_command_with_given_input(\"from\",self.fromm,command)\n        command = self.extend_command_with_given_input(\"to\",self.to,command)\n        command = self.extend_command_with_given_input(\"source\",self.source,command)\n        command = self.extend_command_with_given_input(\"destination\",self.destination,command)\n        command = self.extend_command_with_given_input(\"log-setting\",self.log_setting,command)\n        command = self.extend_command_with_given_input(\"hip-profiles\",self.hip_profiles,command)\n\n        command += \"icmp-unreachable \"+(\"yes\" if self.is_icmp_unreachable else \"no\")+\" \"\n\n        output_commands.append(command)\n\n        output = {}\n        output[\"status\"] = \"success\"\n        output[\"commands\"] = output_commands\n        output[\"rollback\"] = self.get_input_dict()\n        return output\n\n    def extend_command_with_given_input_string(self,key,value,command):\n        if value:\n            command += key+\" \"+value+\" \"\n        return command\n\n    def extend_command_with_given_input_list(self,key,list_value,command):\n        if list_value:\n            command += key+\" [\"\n            for value in list_value:\n                command += \" \"+value+\" \"\n            command += \"] \"\n        return command\n\n    def extend_command_with_given_input(self,key,list_value,command):\n        if type(list_value).__name__==\"str\":\n            return self.extend_command_with_given_input_string(key,list_value,command)\n        elif type(list_value).__name__==\"list\":\n            return self.extend_command_with_given_input_list(key,list_value,command)\n        else:\n            return command\n    \n    def delete(self):\n        logger.info(\"Deletion Started\")\n        try:\n            if self.is_deferred:\n                return self.delete_deferred()\n            else:\n                return self.delete_immediate()\n        except Exception as exception:\n            output = {}\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[\"status\"] = \"failed\"\n            output[\"error\"] = str(exception)\n            output[\"error_trace\"] = str(error_trace)\n            return output\n\n\n    def delete_immediate(self):\n        logger.info(\"Delete Immediate not supported\")\n        return {\"status\":\"failed\",\"message\":\"not supported\"}\n\n    def delete_deferred(self):\n        output_commands = []\n        command = \"delete device-group \"+self.device_group+\" pre-rulebase security \"\n\n        if self.name:\n            command += \"rules \"+self.name+\" \"\n        output_commands.append(command)\n        output = {}\n        output[\"status\"] = \"success\"\n        output[\"commands\"] = output_commands\n        return output\n\n# FIXME: Prevalidation functionality to be added\n    @classmethod\n    def carry_out_pre_validation_activity_for_tabular_input(self, input_dict):\n        activity_output = []\n        output_dict = {}\n        output_dict['device_name'] =  input_dict['device_name']\n        output_dict['operation_type'] =  input_dict['operation_type']\n        output_dict['data'] = []\n        output_dict['commands'] = [\"show device-group \" +input_dict['device_group']+\" pre-rulebase security rules \"+input_dict['name']]\n        activity_output.append(output_dict)\n       \n        return activity_output\n\n# FIXME: PostValidation functionality to be added\n    \n    def carry_out_post_validation_activity_for_tabular_input(self):\n        activity_output = []\n        output_dict = {}\n        output_dict['device_name'] = self.device_name\n        output_dict['operation_type'] = self.operation_type\n        output_dict['data'] = []\n        output_dict['commands'] = [\"show device-group \" +self.device_group+\" pre-rulebase security rules \"+self.name]\n        activity_output.append(output_dict)\n        return activity_output\n\n    # FIXME: Partial Rollback functionality to be added\n    \n    def generate_partial_rollback_commands(self, rollback_input):\n        activity_output = []\n        for rollback_dict in rollback_input:\n            \n            output_dict = {}\n            output_dict['device_name'] = rollback_dict['device_name']\n            output_dict['operation_type'] = rollback_dict['operation_type']\n            output_dict['data'] = []\n            if rollback_dict['operation_type'] == \"create\":\n                output_dict['commands'] = self.delete_deferred()['commands']\n            elif rollback_dict['operation_type'] == \"delete\":\n                output_dict['commands'] = self.create_deferred()['commands']\n            else:\n                output_dict['commands'] = []\n            activity_output.append(output_dict)\n        return activity_output\n\n\n\n\n\n\n    @classmethod\n    def handle_strip(self,input):\n        if type(input).__name__ == 'str':\n            return input.strip() if (input!=None and input!='') else input\n        return input\n\n    @classmethod\n    def mandatory_string_validation(self,input,key,is_error_update):\n        output = input != None and input != ''\n        if not output and is_error_update:\n            logger.info(key + \" Validation Failed with \"+str(input))    \n        return output","description":"FirewallPanoramaPolicy","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":{"committed":true,"pendingForPushAction":true,"pushActionCompleted":false,"enabledForRemoteRepository":true,"connectedRepo":null},"_id":"FirewallPanoramaPolicy","_keywords":["FirewallPanoramaPolicy","Version 3.x"]}