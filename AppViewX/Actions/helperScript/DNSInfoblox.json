{"name":"DNSInfoblox","scriptType":"Python","scriptContent":"import requests\nimport logger_util\nfrom requests.auth import HTTPBasicAuth\nfrom base64 import b64encode\nimport traceback\nimport oob_task_utility\nimport oob_constants\n\nlogger = logger_util.get_logger('DNS Infoblox Record')\n\nclass DNSInfoblox:\n\n    FQDN = \"fqdn\"\n    NAME = \"name\"\n    PTRD_NAME = \"ptrdname\"\n    ZONE = 'zone'\n    VIEW = 'view'\n    IPV4ADDR = 'ipv4addr'\n    IPV6ADDR = 'ipv6addr'\n    SUBNET = 'subnet'\n    TEXT = 'text'\n    MAIL_EXCHANGER = 'mail_exchanger'\n    CANONICAL= 'canonical'\n    COMMENT = 'comment'\n    IS_DISABLE = 'is_disable'\n    CREATOR = 'creator'\n    DDNS_PRINCIPAL = 'ddns_principal'\n    DDNS_PROTECTED = 'ddns_protected'\n    EXTATTRS = 'extattrs'\n    FORBID_RECLAMATION = 'forbid_reclamation'\n    TTL = 'ttl'\n    USE_TTL = 'use_ttl'\n    PREFERENCE = 'preference'\n    \n\n#optional fields used in Host record creation\n    ALIASES = \"aliases\"\n    ALLOW_TELNET = \"allow_telnet\"\n    USE_CLI_CREDENTIALS = \"use_cli_credentials\"\n    CLI_CREDENTIALS =\"cli_credentials\"\n    CONFIGURE_FOR_DNS = \"configure_for_dns\"\n    DEVICE_DESCRIPTION = \"device_description\"\n    DEVICE_LOCATION= \"device_location\"\n    DEVICE_VENDOR = \"device_vendor\"\n    DISABLE = \"disable\"\n    DISABLE_DISCOVERY = \"disable_discovery\"\n    DNS_ALIASES= \"dns_aliases\"\n    RRSET_ORDER = \"rrset_order\"\n    USE_SNMP3_CREDENTIAL = \"use_snmp3_credential\"\n    USE_SNMP_CREDENTIAL = \"use_snmp_credential\"\n    SNMP3_CREDENTIAL = \"snmp3_credential\"\n    SNMP_CREDENTIAL = \"snmp_credential\"\n\n#-----\n\n\n\n\n    PROPOSED_NAME = 'proposed_name'\n    PROPOSED_PTRD_NAME = 'proposed_ptrdname'\n    PROPOSED_ZONE = 'proposed_zone'\n    PROPOSED_IPV4ADDR = 'proposed_ipv4addr'\n    PROPOSED_IPV6ADDR = 'proposed_ipv6addr'\n    PROPOSED_IPV4ADDRS = 'proposed_ipv4addrs'\n    PROPOSED_IPV6ADDRS = 'proposed_ipv6addrs'\n    PROPOSED_CANONICAL = 'proposed_canonical'\n    PROPOSED_TEXT = 'proposed_text'\n    PROPOSED_MAIL_EXCHANGER = 'proposed_mail_exchanger'\n\n    \n    NAMES = 'names'\n    PTRD_NAMES = 'ptrdnames'\n    IPV4ADDRS = 'ipv4addrs'\n    IPV6ADDRS = 'ipv6addrs'\n    TEXTS = 'texts'\n    CANONICALS = 'canonicals'\n    MAIL_EXCHANGERS = 'mail_exchangers'\n    ZONES = 'zones'\n    FQDNS = 'fqdns'\n\n    RECORD_TYPE = \"record_type\"\n    A_RECORD_TYPE = 'a'\n    PTR_RECORD_TYPE = 'ptr'\n    CNAME_RECORD_TYPE = 'cname'\n    MX_RECORD_TYPE = 'mx'\n    TXT_RECORD_TYPE = 'txt'\n    AAAA_RECORD_TYPE = 'aaaa'\n    HOST_RECORD_TYPE = 'host'\n    DISABLE = 'disable'\n\n    properties_data_type = {\n        NAME : 'str',\n        PTRD_NAME : 'str',\n        ZONE : 'str',\n        VIEW : 'str', \n        IPV4ADDR : 'str',\n        IPV6ADDR : 'str',\n        SUBNET : 'str',\n        TEXT : 'str',\n        MAIL_EXCHANGER : 'str',\n        CANONICAL : 'str',\n        COMMENT : 'str',\n        PREFERENCE : 'int',\n        DISABLE : 'bool',\n        CREATOR : 'str',\n        DDNS_PRINCIPAL : 'str',\n        DDNS_PROTECTED : 'bool',\n        EXTATTRS : 'json',\n        FORBID_RECLAMATION :'bool',\n        TTL : 'int',\n        USE_TTL : 'bool',\n        PREFERENCE : 'int'\n    }\n    default_value_dict = {'ttl':28800}\n    \n    operation_type_wise_method_names = {\n        \"create\": {\n            oob_constants.FIELD_VALIDATION: \"validate_fields_create\",\n            oob_constants.PRE_VALIDATION: \"prevalidate_create\",\n            oob_constants.IMPLEMENTATION: \"create\",\n            oob_constants.POST_VALIDATION: \"postvalidate_create\",\n            oob_constants.ROLLBACK: \"delete\",\n            oob_constants.PARTIAL_ROLLBACK : \"delete_partial_rollback\"\n        },\n        \"delete\": {\n            oob_constants.FIELD_VALIDATION:\n            \"validate_fields_for_delete_and_modify\",\n            oob_constants.PRE_VALIDATION: \"postvalidate_create\",\n            oob_constants.IMPLEMENTATION: \"delete\",\n            oob_constants.POST_VALIDATION: \"prevalidate_create\",\n            oob_constants.ROLLBACK: \"create\",\n            oob_constants.PARTIAL_ROLLBACK : \"create\"\n        },\n        \"modify\": {\n            oob_constants.FIELD_VALIDATION:\n            \"validate_fields_for_delete_and_modify\",\n            oob_constants.PRE_VALIDATION: \"postvalidate_create\",\n            oob_constants.IMPLEMENTATION: \"modify\",\n            oob_constants.POST_VALIDATION: \"postvalidate_modify\",\n            oob_constants.ROLLBACK: \"modify\",\n            oob_constants.PARTIAL_ROLLBACK : \"modify\"\n        }\n    }\n\n    #Function to validate the input_dict\n    @classmethod\n    def validate_fields_create(self,input_dict):\n        logger.info(\"Validating the Record Creation Input Data \")\n        status,failure_field = self.validate_fields_create_for_specific_record_type(input_dict)\n        if status and not input_dict[oob_constants.IS_ROLLBACK]:\n           status_all,failure_field_all = self.validate_fields_for_given_list(input_dict,status,failure_field,self.list_of_fields_for_create_validation)\n           status = status and status_all\n           failure_field = failure_field_all \n        return status,failure_field\n\n    @classmethod\n    def validate_fields_for_delete_and_modify(self,input_dict):\n        logger.info(\"Validating the Record Input Data \")\n        status,failure_field = self.validate_fields_delete_and_modify_for_specific_record_type(input_dict)\n        if status and not input_dict[oob_constants.IS_ROLLBACK]:\n           status_all,failure_field_all = self.validate_fields_for_given_list(input_dict,status,failure_field,self.list_of_fields_for_create_validation)\n           status = status and status_all\n           failure_field = failure_field_all\n        return status,failure_field\n\n    @classmethod\n    def validate_fields_for_given_list(self,input_dict,status,failure_field,list_of_fields):\n        for field_name in list_of_fields:\n            status = status and self.mandatory_string_validation(input_dict[field_name],field_name,True)\n            failure_field = field_name if not status and failure_field == None else failure_field\n        if not status:\n            logger.info(\"INPUT VALIDATION FAILED\")\n        else:\n            logger.info(\"INPUT VALIDATION SUCCESS\")\n                \n        return status,failure_field\n\n    #Function to clean the input data\n    @classmethod\n    def clean_input_data(self,input_dict):\n            logger.info(\"Input Received Before clean : \"+str(input_dict))\n\n            for each_field in self.list_of_fields_for_clean:\n                input_dict[each_field]              =   oob_task_utility.handle_strip_for_dict(input_dict,each_field)    \n\n            logger.info(\"Input Received After clean : \"+str(input_dict))\n\n    @classmethod\n    def mandatory_string_validation(self, input, key, is_error_update):\n        output = input != None and input != ''\n        if not output and is_error_update:\n            logger.info(key + \" Validation Failed with \" + str(input))\n        return output\n\n    @classmethod\n    def ipv4addr_subnet_validation(self, ipv4addr, subnet):\n        return oob_task_utility.ipv4addr_validation(ipv4addr,DNSInfoblox.IPV4ADDR) or oob_task_utility.subnet_validation(subnet, DNSInfoblox.SUBNET)\n\n    @classmethod\n    def validation_fail_output(self):\n        output = {}\n        output[oob_constants.STATUS] = oob_constants.FAILED\n        output[oob_constants.MESSAGE] = \"Validation failed\"\n        logger.info(\"output : \" + str(output))\n        return output\n\n    def __init__(self):\n        super().__init__\n\n    def create(self):\n        logger.info(\"Creation Started\")\n        try:\n            if self.is_deferred_execution:\n                return self.create_deferred()\n            else:\n                return self.create_immediate()\n        except Exception as exception:\n            output = {}\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\" + str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            return output\n\n    def delete(self):\n        logger.info(\"Deletion Started\")\n        output = {}\n        try:\n            if self.is_deferred_execution:\n                output = self.delete_deferred()\n            else:\n                output = self.delete_immediate()\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\" + str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during delete operation\")\n        return output\n\n    def modify(self):\n        logger.info(\"Modification Started\")\n        output = {}\n\n        self.modify_swap()        \n        try:\n            if self.is_deferred_execution:\n                return self.modify_deferred()\n            else:\n                return self.modify_immediate()\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\" + str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during modify operation\")\n            return output\n\n    # Method to execute deferred record Creation\n    def create_deferred(self):\n        logger.info(\"Creation Deferred Started\")\n        request_dict = self.get_request_dict_for_record_creation()\n\n        rest = {}\n        rest[oob_constants.DEVICE_NAME] = self.device_name\n        rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n        rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n        rest[oob_constants.HEADERS] = self.get_authorization_dict()\n        rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD] if oob_constants.PAYLOAD in request_dict else {}\n    \n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n        output[oob_constants.ROLLBACK] = self.__dict__\n        self.add_record_type_specific_fields(output)\n        return output\n\n    #Method to execute delete Record immediate\n    def delete_immediate(self, param_dict):\n        logger.info(\"Deletion Immediate Started\")\n        output = {}\n        try:\n            record_response = self.retrieve_record_reference(param_dict)\n            if oob_constants.RESULT in record_response and len(\n                    record_response[oob_constants.RESULT]) > 0:\n                delete_record_response = self.delete_record_details_immediate(\n                    record_response[oob_constants.RESULT][0][\"_ref\"])\n                if delete_record_response is False:\n                    logger.info(\"error : \" + self.record_type +\n                                \" record deletion is failed\")\n                    raise Exception(\"Error in deleting the \" + self.record_type +\n                                    \" Record.\")\n                rollback_input_dict = self.build_delete_rollback_input(\n                    record_response[oob_constants.RESULT][0])\n                output[oob_constants.STATUS] = oob_constants.SUCCESS\n                output[oob_constants.ROLLBACK] = rollback_input_dict\n                output[\n                    oob_constants.RESULT] = \"Delete carried out successfully\"\n            else:\n                raise Exception(\"Error in fetching the \" + self.record_type +\n                                \" Record. \" + self.record_type +\n                                \" Record was not found in device\")\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\" + str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n        return output\n\n    #Method to execute delete record deferred\n    def delete_deferred(self, param_dict):\n        logger.info(\"Deletion Generate Commands Started\")\n        rest = {}\n        record_response = self.retrieve_record_reference(param_dict)\n        if oob_constants.RESULT in record_response and len(\n                record_response[oob_constants.RESULT]) > 0:\n            delete_request_dict = self.get_request_dict_for_record_deletion(\n                record_response[oob_constants.RESULT][0][\"_ref\"])\n            rest[oob_constants.DEVICE_NAME] = self.device_name\n            rest[oob_constants.REST_URL] = delete_request_dict[\n                oob_constants.REST_URL]\n            rest[oob_constants.REST_METHOD] = delete_request_dict[\n                oob_constants.REST_METHOD]\n            rest[oob_constants.HEADERS] = self.get_authorization_dict()\n            rest[oob_constants.PAYLOAD] = {}\n        else:\n            raise Exception(\"Error in fetching the \" + self.record_type +\n                            \" Record. \" + self.record_type +\n                            \" Record was not found in device\")\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n\n        output[oob_constants.ROLLBACK] = self.__dict__\n\n        return output\n\n    #Method to prepare rest for delete partial rollback\n    def delete_partial_rollback_rest(self, param_dict):\n        logger.info(\"Inside delete_partial_rollback_rest :\" + str(param_dict))\n        request_dict = self.get_request_dict_for_record_retrieval(param_dict)\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = []\n\n        rest = {}\n        rest[oob_constants.DEVICE_NAME] = self.device_name\n        rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n        rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n        rest[oob_constants.HEADERS] = self.get_authorization_dict()\n        rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD] if oob_constants.PAYLOAD in request_dict else {}\n        rest[oob_constants.RESPONSE_TYPE] = oob_constants.JSON\n        rest[oob_constants.REQUIRED_PARAM] = oob_constants.REFERENCE\n        rest[oob_constants.PATH_OF_THE_PARAM] = oob_constants.REF\n        output[oob_constants.IMPLEMENTATION_REST].append(rest)\n\n\n        delete_url = 'https://' + self.device_ip + '/wapi/v' + self.api_version + '/$$reference$$&_return_type=json-pretty'\n        delete_rest = {}\n        delete_rest[oob_constants.DEVICE_NAME] = self.device_name\n        delete_rest[oob_constants.REST_URL] = delete_url\n        delete_rest[oob_constants.REST_METHOD] = 'DELETE'\n        delete_rest[oob_constants.HEADERS] = self.get_authorization_dict()\n        delete_rest[oob_constants.PAYLOAD] = {}\n        output[oob_constants.IMPLEMENTATION_REST].append(delete_rest)\n\n        return output\n\n\n    # Deferred validation for both(prevalidation and postvalidation)  \n    def validate_record_creation_deferred(self,validate_type,param_dict):\n        logger.info(\"Validate Record Creation Started\")\n        request_dict = self.get_request_dict_for_record_retrieval(param_dict)\n\n        rest = {}\n        rest[oob_constants.DEVICE_NAME] = self.device_name\n        rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n        rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n        rest[oob_constants.HEADERS] = self.get_authorization_dict()\n        rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD] if oob_constants.PAYLOAD in request_dict else {}\n    \n        return {oob_constants.VALIDATION_REST:[rest]}\n\n    #Method to delete the record\n    def delete_record_details_immediate(self, record_reference):\n        if (record_reference):\n            request_dict = self.get_request_dict_for_record_deletion(\n                record_reference)\n            json_response = {}\n\n            logger.info(\"Delete Record Details URL : \" +\n                        str(request_dict[oob_constants.REST_URL]))\n\n            response = requests.delete(\n                request_dict[oob_constants.REST_URL],\n                verify=False,\n                auth=HTTPBasicAuth(self.device_user_name,\n                                   self.device_password))\n            json_response = response.json()\n            logger.info(\"Delete Record Details : \" + str(json_response))\n            if \"Error\" not in json_response:\n                return True\n            else:\n                logger.info(\"Delete Record Details Call was failed\")\n                raise Exception(\"Error in Deleting the Record\")\n        else:\n            raise Exception(\n                \"Error in Deleting the Record. Record Reference Not Available\")\n\n    def get_authorization_dict(self):\n        authorization = {}\n        authorization['authorization'] = 'Basic %s' % b64encode(\n            str.encode(self.device_user_name + \":\" +\n                       self.device_password)).decode(\"ascii\")\n        authorization['content-type'] = \"application/json\"\n\n        return authorization\n\n    def retrieve_record_reference(self,  param_dict):\n        json_response = {}\n        url = 'https://' + self.device_ip + '/wapi/v' + self.api_version + '/record:' + self.record_type + '?'\n\n        for key in param_dict:\n            url = url + key + '=' + str(param_dict[key]) + \"&\"\n        url = url[0:len(url) - 1]\n\n        logger.info(\"Find Record Details URL : \" + str(url))\n\n        response = requests.get(\n            url,\n            verify=False,\n            auth=HTTPBasicAuth(self.device_user_name, self.device_password))\n        json_response = response.json()\n        logger.info(\"Find Record Details : \" + str(json_response))\n\n        if (json_response and len(json_response[oob_constants.RESULT]) > 0):\n            logger.info(\"Find Record Ref details : \" + str(json_response))\n        else:\n            logger.info(\"Record is not found in device\")\n\n        return json_response\n\n    def get_request_dict_for_record_retrieval(self,param_dict):\n        output = {}\n\n        url = 'https://' + self.device_ip + '/wapi/v' + self.api_version + '/record:' + self.record_type + '?'\n\n        for key in param_dict:\n            url = url + key + '=' + str(param_dict[key]) + \"&\"\n        url = url[0:len(url) - 1]\n\n        output[oob_constants.REST_URL] = url\n        output[oob_constants.REST_METHOD] = 'GET'\n        return output\n\n    def get_request_dict_for_record_deletion(self, record_reference):\n        output = {}\n\n        url = 'https://' + self.device_ip + '/wapi/v' + self.api_version + '/' + record_reference + '&_return_as_object=1'\n\n        output[oob_constants.REST_URL] = url\n        output[oob_constants.REST_METHOD] = 'DELETE'\n        return output\n\n    def returnFieldValueIfNotNone(self, field_key, response,\n                                  modified_fields_dict):\n        if field_key in modified_fields_dict:\n            if field_key in response:\n                return response[field_key]\n            else:\n                return \"\"\n        else:\n            return None\n\n    def addFieldIfNotNoneForModifyRollback(self, payload, key, value):\n        if (self.is_rollback and value != None) or (value != None\n                                                    and value != \"\"):\n            payload[key] = value\n\n    def addFieldIfNotNone(self, payload, key, value):\n        if (value != None and value != \"\"):\n            payload[key] = value\n\n    #Method to Postvalidate for Record Creation\n    def validate_record(self, param_dict, is_required):\n        logger.info(\"Validation Started\")\n        output = {}\n        if self.is_deferred_execution:\n            output = self.validate_record_creation_deferred(\n                oob_constants.POST_VALIDATION,param_dict)\n            output[oob_constants.STATUS] = oob_constants.SUCCESS\n        else:\n            record_response = self.retrieve_record_reference(param_dict)\n            if oob_constants.RESULT in record_response and (\n                    len(record_response[oob_constants.RESULT]) > 0\n                    if not is_required else len(\n                        record_response[oob_constants.RESULT]) == 0):\n                output[oob_constants.STATUS] = oob_constants.FAILED\n                output[oob_constants.ERROR] = str(\"Validation Error : \" + str(self.__dict__))\n        return output","description":"DNSInfoblox","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":{"committed":true,"pendingForPushAction":true,"pushActionCompleted":false,"enabledForRemoteRepository":true,"connectedRepo":null},"_id":"DNSInfoblox","_keywords":["DNSInfoblox","Version 3.x"]}