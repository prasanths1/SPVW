{"name":"DNSInfobloxHostRecord","scriptType":"Python","scriptContent":"'''\n------------------------------------------------------\nTask Description :\n------------------------------------------------------\nThis task is used to create, modify and delete Host Record in Infloblox DNS device. It supports assigning Hostname (name + zone) to,\n\n��         IPAddress ( or )\n��         Next available address from the subnet\n\n. No rollback supported for Deferred task execution with subnet ( free ip auto detection )\n------------------------------------------------------\nVendor, Version Support :\n------------------------------------------------------\nVendor : Infoblox\nVersion : Version: 7.3.4-322642\n------------------------------------------------------\nTask Version : v1.0\nTask Type : Leaf Task\nExecution Type : Immediate and Deferred\nChecksum : f19b879a7905dbb790d845240d1f36b9\n'''\nimport ast\n\nimport re\nimport requests\nimport json\nimport time\nimport traceback\nimport sys\nimport logger_util\n\n\nsys.path.insert(0,AVX::HELPER)\nsys.path.insert(0,AVX::DEPENDENCIES)\nimport infoblox_helper as infoblox\nimport Decrypt_Python3 as Decrypt\nfrom requests.auth import HTTPBasicAuth\nfrom base64 import b64encode\nimport oob_task_utility\nimport oob_constants\nfrom DNSInfoblox import DNSInfoblox\n\nlogger = logger_util.get_logger('DNS Infoblox Host Record')\n\nnull = None\n\n# DNSInfobloxHOstRecord - This class handles the Host Record Creation along with its rollback\nclass DNSInfobloxHostRecord(DNSInfoblox):\n\n    list_of_fields_for_clean = [    \n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    DNSInfoblox.PROPOSED_ZONE,\n                                    DNSInfoblox.VIEW,\n                                    DNSInfoblox.IPV4ADDRS,\n                                    DNSInfoblox.IPV6ADDRS,\n                                    DNSInfoblox.PROPOSED_IPV4ADDRS,\n                                    DNSInfoblox.PROPOSED_IPV6ADDRS,\n                                    DNSInfoblox.ALIASES,\n                                    DNSInfoblox.CLI_CREDENTIALS,\n                                    DNSInfoblox.DEVICE_DESCRIPTION,\n                                    DNSInfoblox.DEVICE_LOCATION,\n                                    DNSInfoblox.DEVICE_VENDOR,\n                                    DNSInfoblox.DNS_ALIASES,\n                                    DNSInfoblox.RRSET_ORDER,\n                                    DNSInfoblox.SNMP3_CREDENTIAL,\n                                    DNSInfoblox.SNMP_CREDENTIAL,\n                                    oob_constants.DEVICE_NAME\n                                ]\n    list_of_fields_for_create_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                ]\n    list_of_fields_for_delete_modify_validation = [\n                                    DNSInfoblox.NAME,\n                                    DNSInfoblox.ZONE,\n                                    oob_constants.DEVICE_NAME,\n                                    DNSInfoblox.IPV4ADDRS,\n                                    DNSInfoblox.IPV6ADDRS\n                                ]\n\n    @classmethod\n    def validate_fields_create_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n\n        ipv4addr_subnet_validation_result = (   self.mandatory_string_validation(input_dict[DNSInfoblox.IPV4ADDRS],\n                                                DNSInfoblox.IPV4ADDRS,False) or self.mandatory_string_validation(input_dict[DNSInfoblox.IPV6ADDRS],\n                                                DNSInfoblox.IPV6ADDRS,False))\n        if not ipv4addr_subnet_validation_result:\n            logger.info(\"IP address validation failed\")\n        status = status and ipv4addr_subnet_validation_result\n        failure_field = \"IP address validation \" if not status and failure_field == None else failure_field\n\n        return status,failure_field\n\n    @classmethod\n    def validate_fields_delete_and_modify_for_specific_record_type(self,input_dict):\n        failure_field = None\n        status = True\n        status1 = True\n        status = status and self.mandatory_string_validation(input_dict[DNSInfoblox.IPV4ADDRS],DNSInfoblox.IPV4ADDRS,True)\n        status1 = status1 and self.mandatory_string_validation(input_dict[DNSInfoblox.IPV6ADDRS],DNSInfoblox.IPV6ADDRS,True)\n        failure_field = DNSInfoblox.IPV4ADDRS if not status and failure_field == None else (DNSInfoblox.IPV6ADDRS if not status1 and failure_field == None else failure_field)\n        \n        return status,failure_field\n\n    def __init__(self, input_dict):\n        logger.info(\"Creating Object with input :\"+str(input_dict))\n        self.name                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.NAME)\n        self.proposed_name          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_NAME)\n        self.zone                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ZONE)\n        self.proposed_zone          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_ZONE)\n        self.view                   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.VIEW)\n        self.ipv4addrs               = self.generate_ipaddr_list_based_on_version(oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IPV4ADDRS), DNSInfoblox.IPV4ADDR)\n        self.ipv6addrs               = self.generate_ipaddr_list_based_on_version(oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.IPV6ADDRS), DNSInfoblox.IPV6ADDR) \n        self.proposed_ipv4addrs      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_IPV4ADDRS)\n        self.proposed_ipv6addrs      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.PROPOSED_IPV6ADDRS)\n        \n        #optional fields for host record\n\n        self.aliases                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ALIASES)\n        self.allow_telnet           = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.ALLOW_TELNET)\n        self.use_cli_credentials    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_CLI_CREDENTIALS)\n        self.cli_credentials        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CLI_CREDENTIALS)\n        self.configure_for_dns      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.CONFIGURE_FOR_DNS)\n        self.ddns_protected         = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DDNS_PROTECTED)\n        self.device_description     = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DEVICE_DESCRIPTION)\n        self.device_location        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DEVICE_LOCATION)\n        self.device_vendor          = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DEVICE_VENDOR)\n        self.disable                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DISABLE)\n        self.disable_discovery      = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DISABLE_DISCOVERY)\n        self.dns_aliases            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.DNS_ALIASES)\n        self.rrset_order            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.RRSET_ORDER)\n        self.use_snmp3_credential   = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_SNMP3_CREDENTIAL)\n        self.use_snmp_credential    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_SNMP_CREDENTIAL)\n        self.snmp3_credential       = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.SNMP3_CREDENTIAL)\n        self.snmp_credential        = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.SNMP_CREDENTIAL)\n        \n        #-----\n        \n        self.ttl                    = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.TTL)\n        self.use_ttl                = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.USE_TTL)\n\n        self.subnet                 = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.SUBNET)\n\n        self.device_name            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.DEVICE_NAME) \n        self.device_ip              = infoblox.get_device_ip(self.device_name)\n        \n        self.api_version            = infoblox.get_device_version(self.device_name)\n       \n        username,password           = Decrypt.getpassword(self.device_name)\n        self.device_user_name       = username\n        self.device_password        = password\n\n        self.is_rollback            = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_ROLLBACK) \n        self.rollback_input         = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.ROLLBACK_INPUT)\n        self.is_deferred_execution  = oob_task_utility.getKeyValueIfAvailable(input_dict,oob_constants.IS_DEFERRED_EXECUTION)\n        self.record_type            = oob_task_utility.getKeyValueIfAvailable(input_dict,DNSInfoblox.RECORD_TYPE)\n\n\n    # To generate a list of ipv4/ipv6 addresses based on the input\n    def generate_ipaddr_list_based_on_version(self,listOfIpaddrs, ipVersion):\n        ipaddrList = []\n        if type(listOfIpaddrs).__name__ != \"list\" and listOfIpaddrs != None:\n            list_of_ip_address = listOfIpaddrs.split(\",\")\n            logger.info(str(list_of_ip_address))\n            if ipVersion == DNSInfoblox.IPV4ADDR and len(list_of_ip_address) != 0:\n                for ipaddr in list_of_ip_address:\n                    tempDict = {}\n                    tempDict[DNSInfoblox.IPV4ADDR] = ipaddr\n                    ipaddrList.append(tempDict)                \n            elif ipVersion == DNSInfoblox.IPV6ADDR and len(list_of_ip_address) != 0:\n                for ipaddr in list_of_ip_address:\n                    tempDict = {}\n                    if oob_task_utility.ipv6addr_validation(ipaddr, ipaddr) == True:\n                        tempDict[DNSInfoblox.IPV6ADDR] = ipaddr\n                        ipaddrList.append(tempDict)\n            logger.info(str(ipaddrList))\n            return ipaddrList\n        else:\n            return listOfIpaddrs\n            \n    #Method to Prevalidate for Host Record Creation\n    def prevalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1},False)\n\n    #Method to Postvalidate for Host Record Creation\n    def postvalidate_create(self):\n        return super().validate_record({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1},True)\n\n    def postvalidate_modify(self):\n        validation_name = ( self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name )+'.'+( self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone)\n        return super().validate_record({DNSInfoblox.NAME:validation_name,\"_return_as_object\":1},True)\n\n    #Method to execute immediate Host Record creation\n    def create_immediate(self):\n        logger.info(\"Creation Immediate Started\")\n        request_dict = self.get_request_dict_for_record_creation()\n        output = {}\n        try:\n            response = requests.post(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n            response_json = response.json()\n            logger.info(\"Host Record Creation Response :\"+str(response_json))\n\n            #Check Error in a_record_create_response\n            isAlreadyExists = \"Error\" in response_json and \"already exists\" in str(response_json[\"Error\"])\n            \n            if isAlreadyExists:\n                logger.info(\"Record Already Exists\")\n                raise Exception(\"Record Already Exists\")\n            elif \"Error\" in response_json:\n                raise Exception(str(response_json[\"Error\"]))\n            \n            input_dict = self.__dict__\n            input_dict[DNSInfoblox.IPV4ADDRS] = self.ipv4addrs\n            input_dict[DNSInfoblox.IPV6ADDRS] = self.ipv6addrs\n            output[oob_constants.STATUS] = oob_constants.SUCCESS\n            self.add_record_type_specific_fields(output)            \n            output[oob_constants.ROLLBACK] = input_dict\n\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            logger.info(\"Exception received \"+str(exception))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            # Rollback for failure scenario\n            self.delete_immediate()\n\n        return output\n\n    #Method to execute delete Host Record immediate\n    def delete_immediate(self):\n        output =  super().delete_immediate({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1})\n        if oob_constants.STATUS in output and output[oob_constants.STATUS]==oob_constants.SUCCESS:\n            self.add_record_type_specific_fields(output)            \n        return output\n    \n    #Method to execute delete Host Record deferred\n    def delete_deferred(self):\n        output = super().delete_deferred({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1})        \n        self.add_record_type_specific_fields(output)        \n        return output\n\n    #Method to execute prepare rest for delete partial rollback\n    def delete_partial_rollback(self):\n        logger.info(\"Inside delete_partial_rollback :\")\n        return super().delete_partial_rollback_rest({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_type\":\"json-pretty\"})\n\n\n    def modify_immediate(self):\n        logger.info(\"Implement immediate started\")\n        output = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.IPV4ADDRS+\",\"+DNSInfoblox.IPV6ADDRS})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                response = requests.put(request_dict[oob_constants.REST_URL],data = json.dumps(request_dict[oob_constants.PAYLOAD]), verify = False,auth = HTTPBasicAuth(self.device_user_name,self.device_password))\n                response_json = response.json()\n                logger.info(\"Host Record modification response :\"+str(response_json))\n                if \"Error\" in response_json:\n                    raise Exception(str(response_json[\"Error\"]))\n                #backup the changed properties\n                if not self.is_rollback:\n                    rollback_data = {}\n                    record_response_dict = record_response[oob_constants.RESULT][0]\n                    modified_dict = request_dict[oob_constants.PAYLOAD]\n                    rollback_data = {x:record_response_dict[x] for x in record_response_dict if x in modified_dict} \n                    rollback_input_dict = self.build_modify_rollback_input(rollback_data, request_dict[oob_constants.PAYLOAD])\n                    output[oob_constants.ROLLBACK] = rollback_input_dict\n\n                name = self.name if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_name\n                zone = self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else self.proposed_zone\n                fqdn = self.name+\".\"+self.zone if DNSInfoblox.NAME not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.NAME]\n                ipv4addrs = self.ipv4addrs if DNSInfoblox.IPV4ADDRS not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.IPV4ADDRS]\n                ipv6addrs = self.ipv6addrs if DNSInfoblox.IPV6ADDRS not in  request_dict[oob_constants.PAYLOAD] else request_dict[oob_constants.PAYLOAD][DNSInfoblox.IPV6ADDRS]\n\n                output[oob_constants.STATUS] = oob_constants.SUCCESS\n                output[DNSInfoblox.NAME] = name\n                output[DNSInfoblox.ZONE] = zone\n                output[DNSInfoblox.FQDN] = fqdn\n                output[DNSInfoblox.IPV4ADDRS] = ipv4addrs\n                output[DNSInfoblox.IPV6ADDRS] = ipv6addrs\n                self.add_record_type_specific_fields(output)\n                return output\n            else:\n                raise Exception(\"Error in fetching the Host Record. Host Record was not found in device\")\n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n            output[oob_constants.STATUS] = oob_constants.FAILED\n            output[oob_constants.ERROR] = str(exception)\n            logger.info(\"Exception occurred during modify operation\")    \n            return output\n\n    #Rollback Not supported\n    def modify_deferred(self):\n        logger.info(\"Implement deferred - generating commands started\")\n        rest = {}\n        try:\n            record_response = self.retrieve_record_reference({DNSInfoblox.NAME:self.name+'.'+self.zone,\"_return_as_object\":1,\"_return_fields\":DNSInfoblox.NAME+','+DNSInfoblox.ZONE+','+DNSInfoblox.VIEW+','+DNSInfoblox.IPV4ADDRS+','+DNSInfoblox.IPV6ADDRS})\n            if record_response is not None and len(record_response[oob_constants.RESULT]) > 0:\n                request_dict = self.get_request_dict_for_record_modification(record_response[oob_constants.RESULT][0][\"_ref\"])\n                rest[oob_constants.DEVICE_NAME] = self.device_name\n                rest[oob_constants.HEADERS] = self.get_authorization_dict()\n                rest[oob_constants.REST_URL] = request_dict[oob_constants.REST_URL]\n                rest[oob_constants.REST_METHOD] = request_dict[oob_constants.REST_METHOD]\n                rest[oob_constants.PAYLOAD] = request_dict[oob_constants.PAYLOAD]\n            else:\n                logger.info(\"Error in fetching the Host Record\")\n                raise Exception(\"Error in fetching the Host Record. Host Record was not found in device\")\n            \n        except Exception as exception:\n            error_trace = traceback.format_exc()\n            logger.info(\"error_trace :\"+str(error_trace))\n        output = {}\n        output[oob_constants.IMPLEMENTATION_REST] = [rest]\n        self.add_record_type_specific_fields(output)\n        return output\n\n    # Method to modify Host Record\n    def get_request_dict_for_record_modification(self,record_reference):\n        logger.info(\"Triggered modify Host Record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/'+record_reference+'?_return_fields=name,ipv4addrs,ipv6addrs&_return_as_object=1'\n        payload = {}\n        logger.info(\"type of ttl :\"+str(type(self.ttl)))\n        if (self.proposed_name!=None and self.proposed_name!=self.name ) or (self.proposed_zone!=None and self.proposed_zone!=self.zone):\n            payload_name =(self.proposed_name if self.proposed_name else self.name)+'.'+(self.proposed_zone if self.proposed_zone else self.zone)\n            self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.NAME,payload_name)        \n\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.IPV4ADDRS,self.proposed_ipv4addrs)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.IPV6ADDRS,self.proposed_ipv6addrs)\n        # Optional fields of Host creation\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.ALIASES,self.aliases)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.ALLOW_TELNET,self.allow_telnet)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_CLI_CREDENTIALS,self.use_cli_credentials)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CLI_CREDENTIALS,self.cli_credentials)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.CONFIGURE_FOR_DNS,self.configure_for_dns)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DEVICE_DESCRIPTION,self.device_description)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DEVICE_LOCATION,self.device_location)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DISABLE,self.disable)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DISABLE_DISCOVERY,self.disable_discovery)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.DNS_ALIASES,self.dns_aliases)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.RRSET_ORDER,self.rrset_order)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_SNMP3_CREDENTIAL,self.use_snmp3_credential)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_SNMP_CREDENTIAL,self.use_snmp_credential)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.SNMP3_CREDENTIAL,self.snmp3_credential)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.SNMP_CREDENTIAL,self.snmp_credential)\n        #\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.TTL,self.ttl)\n        self.addFieldIfNotNoneForModifyRollback(payload,DNSInfoblox.USE_TTL,self.use_ttl)\n\n        logger.info(\"Host Record Modify Payload : \"+str(json.dumps(payload)))\n        logger.info(\"Host Record Modify Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'PUT'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    # Method to create 'Host' record\n    def get_request_dict_for_record_creation(self):\n        logger.info(\"Triggered Create Host Record\")\n\n        rest_url = 'https://'+self.device_ip+'/wapi/v'+self.api_version+'/record:'+DNSInfoblox.HOST_RECORD_TYPE+'?_return_fields=name,ipv4addrs,ipv6addrs&_return_as_object=1'\n        payload = {}\n        \n        #Mandatory\n        payload[DNSInfoblox.NAME] = self.name+\".\"+self.zone\n\n        logger.info(\"self.ipv4addrs\"+str(self.ipv4addrs))\n        logger.info(\"self.ipv6addrs\"+str(self.ipv6addrs))\n        \n        # Handle ipv4addr and subnet for creating the records\n        if self.ipv4addrs != None and self.ipv4addrs != \"\":    \n            logger.info(\"ipv4addrs received : \"+str(self.ipv4addrs))\n            payload[DNSInfoblox.IPV4ADDRS] = self.ipv4addrs\n\n        if self.ipv6addrs != None and self.ipv6addrs != \"\":\n            logger.info(\"ipv6addrs received : \"+str(self.ipv6addrs))\n            payload[DNSInfoblox.IPV6ADDRS] = self.ipv6addrs\n\n\n        #Optional\n        self.addFieldIfNotNone(payload,DNSInfoblox.VIEW,self.view)\n        self.addFieldIfNotNone(payload,DNSInfoblox.ALIASES,self.aliases)\n        self.addFieldIfNotNone(payload,DNSInfoblox.ALLOW_TELNET,self.allow_telnet)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_CLI_CREDENTIALS,self.use_cli_credentials)\n        self.addFieldIfNotNone(payload,DNSInfoblox.CLI_CREDENTIALS,self.cli_credentials)\n        self.addFieldIfNotNone(payload,DNSInfoblox.CONFIGURE_FOR_DNS,self.configure_for_dns)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DDNS_PROTECTED,self.ddns_protected)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DEVICE_DESCRIPTION,self.device_description)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DEVICE_LOCATION,self.device_location)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DISABLE,self.disable)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DISABLE_DISCOVERY,self.disable_discovery)\n        self.addFieldIfNotNone(payload,DNSInfoblox.DNS_ALIASES,self.dns_aliases)\n        self.addFieldIfNotNone(payload,DNSInfoblox.RRSET_ORDER,self.rrset_order)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_SNMP3_CREDENTIAL,self.use_snmp3_credential)\n        self.addFieldIfNotNone(payload,DNSInfoblox.USE_SNMP_CREDENTIAL,self.use_snmp_credential)\n        self.addFieldIfNotNone(payload,DNSInfoblox.SNMP3_CREDENTIAL,self.snmp3_credential)\n        self.addFieldIfNotNone(payload,DNSInfoblox.SNMP_CREDENTIAL,self.snmp_credential)\n                 \n\n\n\n        logger.info(\"Host Record Creation Payload : \"+str(json.dumps(payload)))\n        logger.info(\"Host Record Creation Rest Url : \"+str(rest_url))\n\n        output = {}\n        output[oob_constants.REST_URL] = rest_url\n        output[oob_constants.REST_METHOD] = 'POST'\n        output[oob_constants.PAYLOAD] = payload\n\n        return output\n\n    #function to assign the values for rollback\n    def build_delete_rollback_input(self,record_response):\n        rollback_input_dict = {}\n\n        list_of_fields_for_rollback_input_dict_generation = [\n                                                                DNSInfoblox.NAME,\n                                                                DNSInfoblox.ZONE,\n                                                                DNSInfoblox.VIEW,\n                                                                DNSInfoblox.IPV4ADDRS,\n                                                                DNSInfoblox.IPV6ADDRS,\n                                                                DNSInfoblox.ALIASES,\n                                                                DNSInfoblox.ALLOW_TELNET,\n                                                                DNSInfoblox.USE_CLI_CREDENTIALS,\n                                                                DNSInfoblox.CLI_CREDENTIALS,\n                                                                DNSInfoblox.CONFIGURE_FOR_DNS,\n                                                                DNSInfoblox.DDNS_PROTECTED,\n                                                                DNSInfoblox.DEVICE_DESCRIPTION,\n                                                                DNSInfoblox.DEVICE_LOCATION,\n                                                                DNSInfoblox.DEVICE_VENDOR,\n                                                                DNSInfoblox.DISABLE,\n                                                                DNSInfoblox.DISABLE_DISCOVERY,\n                                                                DNSInfoblox.DNS_ALIASES,\n                                                                DNSInfoblox.RRSET_ORDER,\n                                                                DNSInfoblox.USE_SNMP3_CREDENTIAL,\n                                                                DNSInfoblox.USE_SNMP_CREDENTIAL,\n                                                                DNSInfoblox.SNMP3_CREDENTIAL,\n                                                                DNSInfoblox.SNMP_CREDENTIAL,\n                                                                DNSInfoblox.TTL,\n                                                                DNSInfoblox.USE_TTL\n                                                            ]\n        \n        for field_name in list_of_fields_for_rollback_input_dict_generation:\n            rollback_input_dict[field_name]                     = oob_task_utility.getKeyValueIfAvailable(record_response,field_name)\n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = True \n\n        return rollback_input_dict\n\n    #function to assign the values for rollback\n    def build_modify_rollback_input(self,current_device_values,modify_payload):\n        rollback_input_dict = {}\n       \n        rollback_input_dict[DNSInfoblox.PROPOSED_NAME]      = self.proposed_name if self.proposed_name!=None and self.proposed_name!=\"\" else self.name\n        rollback_input_dict[DNSInfoblox.PROPOSED_ZONE]      = self.proposed_zone if self.proposed_zone!=None and self.proposed_zone!=\"\" else self.zone\n        rollback_input_dict[DNSInfoblox.PROPOSED_IPV4ADDRS]  = self.returnFieldValueIfNotNone(DNSInfoblox.IPV4ADDRS,current_device_values, modify_payload) if DNSInfoblox.IPV4ADDRS not in  modify_payload else modify_payload[DNSInfoblox.IPV4ADDRS]\n        rollback_input_dict[DNSInfoblox.PROPOSED_IPV6ADDRS]  = self.returnFieldValueIfNotNone(DNSInfoblox.IPV6ADDRS,current_device_values, modify_payload) if DNSInfoblox.IPV6ADDRS not in  modify_payload else modify_payload[DNSInfoblox.IPV6ADDRS]\n        \n        list_of_field_names_for_rollback_input_dict = [\n                                                        DNSInfoblox.VIEW,\n                                                        DNSInfoblox.ALIASES,\n                                                        DNSInfoblox.ALLOW_TELNET,\n                                                        DNSInfoblox.USE_CLI_CREDENTIALS,\n                                                        DNSInfoblox.CLI_CREDENTIALS,\n                                                        DNSInfoblox.CONFIGURE_FOR_DNS,\n                                                        DNSInfoblox.DDNS_PROTECTED,\n                                                        DNSInfoblox.DEVICE_DESCRIPTION,\n                                                        DNSInfoblox.DEVICE_LOCATION,\n                                                        DNSInfoblox.DEVICE_VENDOR,\n                                                        DNSInfoblox.DISABLE,\n                                                        DNSInfoblox.DISABLE_DISCOVERY,\n                                                        DNSInfoblox.DNS_ALIASES,\n                                                        DNSInfoblox.RRSET_ORDER,\n                                                        DNSInfoblox.USE_SNMP3_CREDENTIAL,\n                                                        DNSInfoblox.USE_SNMP_CREDENTIAL,\n                                                        DNSInfoblox.SNMP3_CREDENTIAL,\n                                                        DNSInfoblox.SNMP_CREDENTIAL,\n                                                        DNSInfoblox.TTL,\n                                                        DNSInfoblox.USE_TTL\n                                                    ]\n\n        for property_field in list_of_field_names_for_rollback_input_dict:\n            #rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n            # Value from current_device_values only if both dict has key in it\n            property_field_value = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)\n            \n            if property_field in DNSInfoblox.default_value_dict and ( property_field_value==None or property_field_value==''):\n                property_field_value = DNSInfoblox.default_value_dict[property_field]\n\n            if property_field_value!=None and property_field_value!='':\n                rollback_input_dict[property_field] = property_field_value\n            #To handle int or bool field_type in case of empty or None from Device\n            elif property_field in DNSInfoblox.properties_data_type:\n                if (property_field_value is None or property_field_value == '') and (DNSInfoblox.properties_data_type[property_field] != 'int' or DNSInfoblox.properties_data_type[property_field] != 'bool'):\n                    rollback_input_dict[property_field]                 = self.returnFieldValueIfNotNone(property_field,current_device_values, modify_payload)  \n\n        self.add_basic_fields_from_object_to_dict(rollback_input_dict)\n        rollback_input_dict[DNSInfoblox.IPV4ADDRS]               = self.ipv4addrs\n        rollback_input_dict[DNSInfoblox.IPV6ADDRS]               = self.ipv6addrs\n        rollback_input_dict[oob_constants.IS_ROLLBACK]          = self.is_rollback\n        rollback_input_dict[DNSInfoblox.RECORD_TYPE]            = self.record_type\n\n        return rollback_input_dict\n    \n    def add_basic_fields_from_object_to_dict(self,output):\n        output[DNSInfoblox.NAME]                   = self.name\n        output[DNSInfoblox.ZONE]                   = self.zone\n        output[oob_constants.DEVICE_NAME]          = self.device_name    \n        output[oob_constants.IS_DEFERRED_EXECUTION]          = self.is_deferred_execution\n        output[oob_constants.ROLLBACK_INPUT]       = self.rollback_input\n\n    def add_record_type_specific_fields(self,output):\n        output[DNSInfoblox.IPV4ADDRS] = self.ipv4addrs\n        output[DNSInfoblox.IPV6ADDRS] = self.ipv6addrs\n        output[DNSInfoblox.NAME] = self.name\n        output[DNSInfoblox.ZONE] = self.zone\n        output[DNSInfoblox.FQDN] = self.name+\".\"+self.zone\n\n    # Method for swapping the object identifier,to handle the change in the name of the identifier\n    def modify_swap(self):\n        if self.is_rollback:\n            if self.name != self.proposed_name and self.proposed_name != None:\n                self.name, self.proposed_name = self.proposed_name, self.name\n            if self.zone != self.proposed_zone and self.proposed_zone != None:\n                self.zone, self.proposed_zone = self.proposed_zone, self.zone\n            if self.ipv4addrs != self.proposed_ipv4addrs and self.proposed_ipv4addrs != None:\n                self.ipv4addrs, self.proposed_ipv4addrs = self.proposed_ipv4addrs, self.ipv4addrs\n            if self.ipv6addrs != self.proposed_ipv6addrs and self.proposed_ipv6addrs != None:\n                self.ipv6addrs, self.proposed_ipv6addrs = self.proposed_ipv6addrs, self.ipv6addrs\n","description":"DNSInfobloxHostRecord","readOnly":false,"version":"Version 3.x","historyReferences":[],"usedHistory":null,"sourceControlSettings":null,"_id":"DNSInfobloxHostRecord","_keywords":["DNSInfobloxHostRecord","Version 3.x"]}